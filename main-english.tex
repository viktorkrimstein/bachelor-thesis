% !TeX document-id = {af928648-7a45-486b-aa45-9066bfc9e040}
% !TeX spellcheck = en-US
% !TeX encoding = utf8
% !TeX program = pdflatex
% !BIB program = biber

\let\ifdeutsch\iffalse
\let\ifenglisch\iftrue
\input{pre-documentclass}
\documentclass[
a4paper,
twoside,
% bibliography=totoc,
% dxtotoc,   %Index ins Inhaltsverzeichnis
% liststotoc, %List of X ins Inhaltsverzeichnis, mit liststotocnumbered werden die Abbildungsverzeichnisse nummeriert
headsepline,
cleardoublepage=empty,
parskip=half,
% draft um zu sehen, wo noch nachgebessert werden muss - wichtig, da Bindungskorrektur mit drin
draft=false
]{scrbook}
\input{config}

\usepackage[
title={Evaluation and Integration of an OPC UA Service into a Container-Based Cloud Platform},
author={Viktor Krimstein},
type=bachelor,
institute=iste, % or other institute names - or just a plain string using {Demo\\Demo...}
course={se},
examiner={Prof.\ Dr.\ Stefan Wagner},
supervisor={Carsten Ellwein,\ M.Sc.\\Dipl.-Ing.\ Wolfgang Fechner},
startdate={November 22, 2017},
enddate={May 22, 2018}
]{scientific-thesis-cover}

\input{acronyms}

\makeindex

\begin{document}

	\iftex4ht
	\Configure{$}{\PicMath}{\EndPicMath}{}
	%$
	\Css{body {text-align:justify;}}
	\Configure{graphics*}
	{pdf}
	{\Needs{"convert \csname Gin@base\endcsname.pdf
			\csname Gin@base\endcsname.png"}%
		\Picture[pict]{\csname Gin@base\endcsname.png}%
	}
	\fi

	%Tipp von http://goemonx.blogspot.de/2012/01/pdflatex-ligaturen-und-copynpaste.html
	%siehe auch http://tex.stackexchange.com/questions/4397/make-ligatures-in-linux-libertine-copyable-and-searchable
	%
	%ONLY WORKS ON MiKTeX
	%On other systems, download glyphtounicode.tex from http://pdftex.sarovar.org/misc/
	%
	\input glyphtounicode.tex
	\pdfgentounicode=1

	%\VerbatimFootnotes %verbatim text in Fußnoten erlauben. Geht normalerweise nicht.

	\input{commands}
	\pagenumbering{arabic}
	\Titelblatt

	%Eigener Seitenstil fuer die Kurzfassung und das Inhaltsverzeichnis
	\deftripstyle{preamble}{}{}{}{}{}{\pagemark}
	%Doku zu deftripstyle: scrguide.pdf
	\pagestyle{preamble}
	\renewcommand*{\chapterpagestyle}{preamble}

	\section*{Abstract}

		In the context of Industry 4.0, services are brought to the forefront along with a higher degree of networking.
		The vision of self-governing systems that exchange information and make decisions without human intervention is a primary goal but not necessarily the focus of many projects.

		The research project ``Rent'n'Produce: Secure Cloud Service for the Commissioning and Control of Production Systems'' which is currently being processed at the Institute for Control Engineering of Machine Tools and Manufacturing Units of the University of Stuttgart, has the vision of advancing self-directed manufacturing systems.
		Companies from different industries should be provided with a Cloud-based platform that enables a highly flexible production order.

		This bachelor thesis focuses on the integration of a real machine tool into the Rent'n'Produce Cloud Platform by using the Open Platform Communications Unified Architecture.
		The required functionality of the integrated service should be encapsulated in a virtualization container.
		This middleware is intended to provide access to configuration and status data of the production resource, to transfer numerical control programs to the machine tool as well as to start or stop the part production.

	\newpage

	\section*{Kurzfassung}

		In heutigen Unternehmen werden zunehmend Konzepte und Technologien des Cloud Computings implementiert. 
		Hierbei können Speicher- und Rechenkapazitäten von Drittanbietern in die eigenen Unternehmensprozesse eingebunden und nach Belieben skaliert werden. 
		Im Rahmen der Industrie 4.0 finden Cloud Computing-Paradigmen zunehmend auch im Automatisierungs- und Steuerungsumfeld ihre Verwendung. Steuerungssysteme, die ganz ohne menschliches Zutun Produktionsprozesse abbilden und durchführen können, stehen jedoch nicht im Fokus aktueller Forschungsprojekte.

		Das Forschungsprojekt \glqq Rent'n'Produce: Sicherer Cloudservice zur Beauftragung und Steuerung von Fertigungssystemen\grqq{}, welches aktuell am Institut für Steuerungstechnik der Werkzeugmaschinen und Fertigungseinrichtungen der Universität Stuttgart bearbeitet wird, will genau diese Lücke schließen.
		Konsumenten und Produzenten unterschiedlicher Wirtschaftszweige soll eine cloudbasierte Plattform zu Verfügung gestellt werden, mit der Automatisierungsprozesse bis hin zu administrativen Operationen auf Produktionsressourcen realisiert werden können.

		Ziel dieser Arbeit ist die Anbindung einer realen Werkzeugmaschine basierend auf der Open Platform Communications Unified Architecture an Rent'n'Produce umzusetzen.
		Die benötigte Funktionalität der Anbindung soll dabei in einem Virtualisierungscontainer gekapselt und über eine standardisierte Webschnittstelle zur Verfügung gestellt werden.
		Diese Middleware soll den Zugriff auf Konfigurations- und Zustandsdaten der Produktionsressource, die Übertragung von Programmen für numerische Steuerungen auf die Maschine sowie das Starten sowie Stoppen von Fertigungsschritten ermöglichen.

	\cleardoublepage

	% BEGIN: Verzeichnisse

	\iftex4ht
	\else
	\microtypesetup{protrusion=false}
	\fi

	%%%
	% Literaturverzeichnis ins TOC mit aufnehmen, aber nur wenn nichts anderes mehr hilft!
	% \addcontentsline{toc}{chapter}{Literaturverzeichnis}
	%
	% oder zB
	%\addcontentsline{toc}{section}{Abkürzungsverzeichnis}
	%
	%%%

	%Produce table of contents
	%
	%In case you have trouble with headings reaching into the page numbers, enable the following three lines.
	%Hint by http://golatex.de/inhaltsverzeichnis-schreibt-ueber-rand-t3106.html
	%
	%\makeatletter
	%\renewcommand{\@pnumwidth}{2em}
	%\makeatother
	%
	\tableofcontents

	% Bei einem ungünstigen Seitenumbruch im Inhaltsverzeichnis, kann dieser mit
	% \addtocontents{toc}{\protect\newpage}
	% an der passenden Stelle im Fließtext erzwungen werden.

	\listoffigures
	\listoftables

	% Wird nur bei Verwendung von der lstlisting-Umgebung mit dem "caption"-Parameter benoetigt
	% \lstlistoflistings
	% ansonsten:
	% \ifdeutsch
	% \listof{Listing}{Verzeichnis der Listings}
	% \else
	% \listof{Listing}{List of Listings}
	% \fi

	% mittels \newfloat wurde die Algorithmus-Gleitumgebung definiert.
	% Mit folgendem Befehl werden alle floats dieses Typs ausgegeben
	% \ifdeutsch
	% \listof{Algorithmus}{Verzeichnis der Algorithmen}
	% \else
	% \listof{Algorithmus}{List of Algorithms}
	% \fi
	% \listofalgorithms %Ist nur für Algorithmen, die mittels \begin{algorithm} umschlossen werden, nötig

	% Abkürzungsverzeichnis
	\printnoidxglossaries

	\iftex4ht
	\else
	% Optischen Randausgleich und Grauwertkorrektur wieder aktivieren
	\microtypesetup{protrusion=true}
	\fi

	% END: Verzeichnisse

	% Headline and footline
	\renewcommand*{\chapterpagestyle}{scrplain}
	\pagestyle{scrheadings}
	\pagestyle{scrheadings}
	\ihead[]{}
	\chead[]{}
	\ohead[]{\headmark}
	\cfoot[]{}
	\ofoot[\usekomafont{pagenumber}\thepage]{\usekomafont{pagenumber}\thepage}
	\ifoot[]{}

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%
	% Main content starts here
	%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\chapter{Introduction} \label{ch:introduction}

		The trend of connecting physical objects with the Internet gave birth to the term \gls{iot}.
		\gls{iot} envisions applications running with interconnected objects working together to gather data and act in environments by controlling different actuators to enable new functionality with minimal human intervention~\cite{atzori2010internet}.
		With the introduction of \gls{iot} and \gls{cps} concepts in industrial application scenarios, automation is undergoing a tremendous change~\cite{wollschlaeger2017future}.
		By adapting these concepts, the philosophy of ``\gls{dama}'' has emerged in the past decade~\cite{heinrichs2005anywhere,venkatesh2005validating,manenti2011building}.
		The \gls{dama} approach demands the ability to exchange design and manufacturing data across multiple sites.
		\gls{dama} also helps establish links between \gls{mrp}, \gls{erp} and \gls{crm}~\cite{xu2012cloud}.

		However, today's networked manufacturing mainly refers to integration of distributed resources for undertaking a single manufacturing task~\cite{li2010cloud}.
		What is lacking in this type of manufacturing regime are the centralized operation management of the services, choice of different operation modes and embedded access of manufacturing equipment and resources, without which a seamless, stable and high quality transaction of manufacturing resource services and a \gls{qos} cannot be guaranteed~\cite{tao2010theory}.
		Further, any attempt to steer processes independently of continuous human interaction requires, in a very wide sense, the flow of information between some kind of sensors, controllers and actuators ~\cite{sauter2011evolution}.

		In the context of \gls{cm}, services with a higher degree of networking are brought to the fore.
		Approaches in this regard often focus on the collection and analysis of data. The vision of self-steering systems that share information and make decisions without human intervention is a primary goal, but not necessarily the focus of many projects.
		With the research project ``\gls{rnp}''~\cite{ellwein2016} which is currently being processed at the \gls{isw}, and its available functionalities at the time of writing this thesis, manufacturers of different industries and sectors can use the Cloud platform for flexible production assignment and detailed order management.
		Furthermore, one goal of \gls{rnp} is to integrate features and functionalities to access machine tools directly from the Cloud and independently of their physical location and the underlying manufacturing platforms by relying only on a homogeneous \gls{m2m} communication standard.

		Unfortunately, the last requirement is quite a difficult one as manufacturers show a huge heterogeneity in the ways and protocols, the machine tools support for communication and data access~\cite{xu2012cloud}.
		Tackling this challenge two specifications emerged within the last years.
		European manufacturers integrated the \gls{opcua} is the extension of its predecessor \gls{opc}, while \gls{dds} gets more popular within the United States~\cite{niggemann2015data}.

		\section{Motivation}\label{sec:motivation}

			\gls{cm} is a concept providing a model to transition traditional manufacturing processes into the Cloud while enabling users of \gls{cm} platforms a cost-effective and efficient way to manage manufacturing resources, production workflows and control units~\cite{xu2012cloud}.
			By adapting principles of Cloud Computing, manufacturers are given the possibility to track, manage and control their machine tools and manufacturing units remotely~\cite{wu2013cloud}.
			It is possible to follow the whole manufacturing process through the whole automation pyramid allowing manufacturers to scale and schedule their production planning and execution according to customers' needs~\cite{kleinemeier2014automatisierungspyramide}.

			Currently the most Use Cases of the \gls{cm} platform focus on the retrieval and gathering of data from machine tools.
			Remote control of the machines and manufacturing processes beyond company boundaries is not in the focus of research.
			The motivation of this work is to provide an architectural approach to provision and manage machine tools of manufacturers remotely and to transfer production data down to the machines using a standard \gls{m2m} communication protocol.
			This work wants to provide a manufacturer and control unit independent approach that allows manufacturers to control their production processes and not only focus on monitoring them. Therefore, a real machine tool should be integrated into the \gls{rnp} platform using the \gls{poc}.
			
			As the control unit of the machine tool, a Beckhoff TwinCAT V3\footnote{\url{http://www.beckhoff.de/twincat3/}} will be used, as it implements nearly the whole \gls{opcua} specification, according to~\cite{twincat2018}.
			By only relying on the \gls{opcua} protocol and the functionalies implemented by the Beckhoff TwinCAT V3 control unit, this work wants to prove, that a machine tool and control unit independent implementation of a \gls{cm} platform can be realized.
			Additionally, this work aims to provide a solid base for future work on the field of remote automation.

		\section{Goals}\label{sec:goals}

			The goal of this thesis is to model the integration of a real machine tool into the \gls{rnp} Cloud platform by using \gls{opcua}.
			Therefore, use-cases will be researched and evaluated to create an architecture, modeling the specified requirements.
			This architecture will later on be tested, using a prototypical implementation of a \gls{poc}.
			The required functionality of the integrated \gls{poc} should be encapsulated in a virtualization container.
			
			This middleware is intended to provide access to configuration and status data of the production resource, to transfer \gls{nc} programs in \gls{gcode} format\footnote{\url{https://www.iso.org/standard/34608.html}}, generated through a \gls{cad} and \gls{cam} process chain, to the machine tool, and to start or stop the part production. 
			
			The resulting \gls{poc} should simulate the \gls{cm} processes beginning with the order management and ending with the production of a real part. Subgoals are defined as follows:

			\begin{enumerate}

				\item Evaluation and specification of an architecture providing the required functionality.

				\item Implementing and integrating a \gls{poc} service based on the developed architecture.
				
				\item The \gls{poc} should provide its functionality using an \gls{api}.

				\item The \gls{poc} should be able to store \gls{gcode} for the production part description.

				\item Integration of a real milling machine to the \gls{rnp} platform using the \gls{poc}.

			\end{enumerate}

		\section{Structure}

			This thesis is structured as follows: In \Cref{ch:foundations}, the scope of this work is described in detail and a brief introduction to the related research field of this work is provided.
			Furthermore, relations to the \gls{rnp} research project and to the field of \gls{cm} are provided as well.
			References to the current state of the art are presented in \cref{ch:state_of_the_art} and will show the stack of technologies and techniques used in this work.
			Afterwards  a differentiated view on the current state of the research is taken in \cref{ch:state_of_the_Science}.
			In this chapter the general state of current research on the topics that relate to this thesis are described by at the same time distancing from the current industrial state.
			Concepts and methodologies of the \gls{poc} to be developed as part this work are discussed in more detail in \Cref{ch:concept}.
			In \Cref{ch:discusion} the results of the \gls{poc} implementation are discussed.
			\Cref{ch:conclusion_and_future_work} concludes the paper and outlines possible future work.

	\chapter{Foundations}\label{ch:foundations}

		In \Cref{ch:introduction} a short summary on \gls{cm} and especially of the challenges in terms of \gls{m2m} communication and the current topology at manufacturing sites was given as well as a motivation, why the integration of new features is beneficial for the research state of \gls{rnp}.
		To better understand the used terms and suggested concepts, this chapter introduces fundamental knowledge related to this work.

		A closer description of the reseach project \gls{rnp} is provided in \Cref{sec:rent_n_produce}.
		The underlying concepts of Cloud Computing are highlighted in \Cref{sec:cloud_computing}.
		Its' applications to manufacturing models are provided in \Cref{sec:cloud_manufacturing} including the \gls{cad}-\gls{cam} process chain.
		Finally, \cref{sec:opc_ua} gives an introduction to the \gls{m2m} communcation protocol used in this work.

		\section{Rent'n'Produce}\label{sec:rent_n_produce}

			The research project \gls{rnp} of the \gls{isw} draws on the existing infrastructure and networking in manufacturing companies and relies on a Cloud-based platform for the commissioning of machine tools and equipment~\cite{xen.17b}. 
			The declared goal of the research project is a highly flexible, location-independent production order across company boundaries.
			The production parts' description required for commissioning can be present in the form of \gls{cad} data or \gls{nc} programs and transmitted to the system by the client.
			
			The provided functionality of the \gls{rnp} platform at the beginning of this work is show in \Cref{fig:rnp_workflow}. \Cref{fig:rnp_workflow} is drawn in \gls{uml}-like syntax for Interaction Diagrams, as described in~\cite{uml2017}, to show the interactions of the different entities in the \gls{rnp} platform. 
			The \gls{rnp} platform provides its' functionalities in a cyclic manner. 
			As shown in \cref{fig:rnp_workflow}, Producers can signal the \gls{rnp} resource management, their current production state and machine tool occupation. 
			The \gls{rnp} middleware then can signal to the Customers, that potential manufacturing resources are available from the Producer or even multiple Producers. 
			In top-down order, \cref{fig:rnp_workflow} shows that Customers can assign production orders to one or multiple Producers, using the Resource Assignment Layer of the \gls{rnp} platform.

			\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{rnp_workflow.jpg}
				\caption{The workflow of the Rent'n'Produce platform adapted from~\cite{ellwein2016}}
				\label{fig:rnp_workflow}
			\end{figure}

			Before commissioning the selected resource at the shop-floor level (the production level at the producer's manufacturing site), the production part descriptions have to go through a postprocessor and then to be adapted to the selected production resource from the resource catalog.
			This thesis deals with the transfer of existing \gls{gcode} data to a production resource.
			The postprocessing of workpiece descriptions is part of a parallel research project.

			\subsection{Initial Architecture}\label{subsec:initial_architecture}

			The architecture is based on several services which work independently of each other following a \gls{soa} approach~\cite{erl2008soa}.
			Each service is split up in a persistence layer and a business logic layer making its functionality accessible to other services using an \gls{api}.
			A simplified view on the architecture of \gls{rnp} is shown in \cref{fig:rnp_architecture} described as \gls{uml} Component Diagram following~\cite{uml2017}.
			
			The persistence layer, shown in \cref{fig:rnp_architecture}, contains the databases (\gls{sql} or \gls{nosql}) for the different services in the overall \gls{soa}. These databases offer their \gls{api}s to the Service Layer, implementing the business logic of the whole \gls{rnp} platform. As presented in \cref{fig:rnp_architecture}, the service layer is encapsulated by the \gls{api} Gateway Component, briding the \gls{api}s of the \gls{rnp} platform to the Web Interface, shown to the end-users of \gls{rnp}.

			\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{rnp_components_simplified.jpg}
				\caption{Simplified architecture of the Rent'n'Produce platform}
				\label{fig:rnp_architecture}
			\end{figure}

			Further, every service is responsible only for one specific part of the whole platform domain(e.g., order management, user access and permission management etc.).
			Through the serverd database interface, the business logic can access the persistence layer to store and retrieve data required for domain specific operations.
			The business logic layer itself, contains all functionality provided by the platform encapsulated to different services.

			Services and databases are encapsulated in virtualization containers to ensure platform independence and the increase of maintainability~\cite{xen.17b}.
			The web interface component is the application layer which contains the \gls{ui} and the \gls{api} gateway routing all client requests to the appropriate services by its internal \gls{url} representation.

		\section{Cloud Computing}\label{sec:cloud_computing}

			By the \gls{nist} definition of Cloud Computing, Cloud Computing is a model for enabling ubiquitous, convenient, on-demand network access to a shared pool of configurable computing resources (e.g., networks, servers, storage, applications, and services) that can be rapidly provisioned and released with minimal management effort or service provider interaction~\cite{mell2011nist}.
			This cloud model is composed of five essential characteristics, three service models, and four deployment
			models~\cite{fehling2014cloud}. 
			With regard to this work, the following paragraphs will focus and describe the three service models, often adapted in the manufacturing environment: \gls{saas}, \gls{paas} and \gls{iaas}.

			\paragraph{Software as a Service} The capability provided to the consumer is to use the provider's applications running on a Cloud infrastructure~\cite{mell2011nist}.
			A Cloud infrastructure is the collection of hardware and software that enables the five essential characteristics of Cloud Computing~\cite{mell2011nist}. 
			The Cloud infrastructure can be viewed as containing both a physical layer and an abstraction layer~\cite{fehling2014cloud}. 
			The physical layer consists of the hardware resources that are necessary to support the Cloud services being provided, and typically includes server, storage and network components~\cite{fehling2014cloud}.
			The abstraction layer consists of the software deployed across the physical layer, which manifests the essential Cloud characteristics~\cite{fehling2014cloud}. 
			Conceptually the abstraction layer sits above the physical layer~\cite{fehling2014cloud}.
			
			The applications are accessible from various client devices through either a thin client interface, such as a web browser (e.g., web-based email), or a program interface~\cite{mell2011nist}.
			The consumer does not manage or control the underlying Cloud infrastructure including network, servers, operating systems, storage, or even individual application capabilities, with the possible exception of limited userspecific application configuration settings~\cite{mell2011nist}.

			\paragraph{Platform as a Service} The capability provided to the consumer is to deploy onto the Cloud infrastructure consumer-created or acquired applications created using programming languages, libraries, services, and tools supported by the provider~\cite{fehling2014cloud}.
			This capability does not necessarily preclude the use of compatible programming languages, libraries, services, and tools from other sources~\cite{leymann2011cloud}.
			
			The consumer does not manage or control the underlying Cloud infrastructure including network, servers, operating systems, or storage, but has control over the deployed applications and possibly configuration settings for the application-hosting environment~\cite{leymann2011cloud}.

			\paragraph{Infrastructure as a Service} The capability provided to the consumer is to provision processing, storage, networks, and other fundamental computing resources where the consumer is able to deploy and run arbitrary software, which can include operating systems and applications~\cite{leymann2011cloud}. 
			The consumer does not manage or control the underlying Cloud infrastructure but has control over operating systems, storage, and deployed applications; and possibly limited control of select networking components (e.g., host firewalls)~\cite{mell2011nist}.

			As shown in \cref{sec:rent_n_produce}, the \gls{rnp} Cloud platform is built upon a \gls{iaas} layer providing its functionality over the \gls{paas} and \gls{saas} models~\cite{xen.17b}. 
			The goals and motivations of this work, can be related to the \gls{paas} model, as machin-tools and manufacturing sites should be provisioned over the services provided by the platform.

		\section{Cloud Manufacturing}\label{sec:cloud_manufacturing}

			With the broad adoption of Cloud Computing concepts and technology in the software industry, especially the use of virtualization, shared resources, outsourcing of high performance workloads, \gls{soa} and the concepts described in \cref{sec:cloud_computing}, \gls{cm} emerged and is getting adapted more and more in the production environment~\cite{he2015state}. \gls{cm} models the relocation of production resources via the internet either at times of equipment peaks or from cost reasons~\cite{wu2013cloud}. Further, \gls{cm} allows its users to access a pool of manufacturing services and resources in a flexible and location independent (only limited by the real-time connectivity required) manner, using an \gls{xaas} payment model only taking the usage time into account~\cite{macia2012cloud}.

			Services offered to the manufactures range from product design and development to manufacturing production of the requested parts~\cite{xu2012cloud}. The provided resources  are managed and encapsulated in a centralized way through the whole automation pyramid~\cite{kleinemeier2014automatisierungspyramide}.
			In a \gls{cm} system, three types of users and roles are defined -- providers, consumers and operators~\cite{wu2013cloud}.

			Providers offer manufacturing resources on the platform.
			Their roles and respective representations can vary from private customers, small business to specialized manufacturing service providers~\cite{tao2014cciot}.
			Clients occupy and use the manufacturing resources provided by the platform by paying for the usage time of the specific machine tools~\cite{he2015state}.
			Last but not least operators are responsible for operating and maintaining the services provided on the platform as well as to deliver services which can be used by both parties mentioned above~\cite{xu2012cloud}.
			Moreover, operators are hold accountable to maintain and modernize the service stack within the platform including, architecture, technologies and security related methodologies~\cite{tedeschi2015security}.
			
			The architecture of a \gls{cm} platform shown in \cref{fig:cloud_manufacturing} in a \gls{uml}-like Interaction Diagram following~\cite{uml2017} is constructed by the following four tiers and three domains: the manufacturing resource layer, virtual service layer, global service layer and the application layer~\cite{wu2013cloud}.
			The product life cycle of manufacturing, including machine tools, gateways and administration tools, is represented by the provider domain and offered by the manufacturing resource layer.
			Resources can either be any kind of \gls{cps} as well as generalized and abstracted manufacturing capabilities~\cite{kleinemeier2014automatisierungspyramide}.
			Manufacturing resources include for instance equipment, servers or \gls{plc} units~\cite{xu2012cloud}.
			
			Abstract manufacturing capabilities describe the ability of producers and manufacturer to offer the possibility for executing specialized, non typical tasks including the associated design, planning and management processes culminating in production site specific hardware and administration tools~\cite{he2015state}.
			The virtual service layer concludes the provider domain by abstracting the underlying manufacturing resource layer and acting as an interface for the global service layer~\cite{xu2012cloud}.
			
			Cloud deployment technologies necessary to run the whole \gls{cm} system and to bridge the provider and user domains are implemented by the global service layer.
			By mentioning Cloud deployment technologies this work refers to \gls{iaas} or a \gls{paas} offering, as described in~\cref{sec:cloud_computing}.
			Two operational modes are enabled for the global service layer -- complete service mode and partial service mode.
			The complete service mode orchestrates all manufacturing processes itself~\cite{xu2012cloud}.
			In the partial service mode, it is possible for providers to take control over the processes at system scope where the global service layer supports the management and organization of these processes.
			
			Finally, the application layer rounds off the \gls{cm} model by being responsible for end-user demand and manufacturing process management mapping~\cite{xu2012cloud}.
			
			\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{cloud_manufacturing.jpg}
				\caption{Architecture of a Cloud Manufacturing system adapted from~\cite{xu2012cloud}}
				\label{fig:cloud_manufacturing}
			\end{figure}

		\section{Open Platform Communications Unified Architecture} \label{sec:opc_ua}

			The \gls{opcua} is the new version of the well-known \gls{opc} architecture~\cite{hadlich2006providing} originally designed by the \gls{opc} Foundation to connect industrial devices to control and supervision applications~\cite{henssen2014online}. 
			The focus of \gls{opc} is on getting access to large amounts of real-time data while ensuring performance constraints without disrupting the normal operation of the devices~\cite{candido2010soa}.
			The original \gls{opc} specifications, based on Microsofts \gls{com}, are becoming obsolete and are gradually being replaced by new interoperability standards, including web-services what led the \gls{opc} Foundation to publish a new architecture, called \gls{opcua}~\cite{hadlich2006providing}.
			
			\paragraph{Notice} The following two figures, shown in~\cref{fig:opc_ua_server_model} and~\cref{fig:opc_ua_client_model} were cited with the kind permission of the \gls{opc} Foundation to cite this images by referencing the origin \gls{opcua} Specification Part referenced in~\cite{opcfoundation2017part1}.

			\subsection{Server Model}\label{subsec:opc_ua_server_model}

				\gls{opcua} specifies the exchange of real-time information of production plant data between control devices or \gls{it} systems from different manufacturers~\cite{venkatesh2005validating}.
				The communication is established by an \textit{inverted} client-server system, where the client triggers actions on the server for automation control, and the server executes the commands on, or retrieves data from the underlying machine~\cite{imtiaz2013scalability}.
				
				\Cref{fig:opc_ua_server_model} shows the \gls{opcua} Server Model according to its specification in~\cite{opcfoundation2017part1}.
				\gls{opcua} servers include an information model that allows users to organize data and their semantics in a structured manner.
				
				This semantic \textit{AddressSpace} is constructed of standalone or interconnected \textit{Node}s mapped to real \gls{cps} object representatives as shown in~\cref{fig:opc_ua_server_model}.
				Furthermore, nodes can be divided into functionality and view nodes, each sort implementing different functionalities and manners of user interaction. Further, each node can be monitored and subscribed by parties of interest using the \gls{opcua} Server \gls{api} as presented at the bottom of~\cref{fig:opc_ua_server_model}.
				The information model constitutes the address spaces of \gls{opcua} servers.
				It is a fullmesh network of nodes with their properties and relations.
				
				In general, users create the information model for their \gls{opcua} servers manually at implementation time or implement vendor-specific automatism~\cite{henssen2014online}.
				A server address space consists of the following element types which are shown in \Cref{fig:opc_ua_server_model}.

				\begin{itemize}

					\item \textit{Object}: ``A \textit{Node} that represents a physical or abstract element of a system. Objects are modeled using the \gls{opcua} \textit{Object Model}. Systems, subsystems and devices are examples of Objects. An Object may be defined as an instance of an ObjectType.''~\cite{opcfoundation2017part1}

					\item \textit{ObjectType}: ``A Node that represents the type definition
					for an Object.''~\cite{opcfoundation2017part1}

					\item \textit{Variable}: ``A Variable is a Node that contains a value.''~\cite{opcfoundation2017part1}

					\item \textit{VariableType}: ``Node that represents the type definition for a Variable''~\cite{opcfoundation2018part3}

					\item \textit{DataType}: ``An instance of a DataType Node that is used together with the \textit{ValueRank} attribute to define the data type of a Variable.''~\cite{opcfoundation2018part3}

					\item \textit{ReferenceType}: ``A Node that represents the type definition of a \textit{Reference}. The ReferenceType specifies the semantics of a Reference. The name of a ReferenceType identifies how source Nodes are related to target Nodes and generally reflects an operation between the two, such as “A Contains B”.''~\cite{opcfoundation2017part1}

					\item \textit{Method}: ``A callable software function that is a component of an Object.''~\cite{opcfoundation2017part1}

					\item \textit{View}: ``A specific subset of the \textit{AddressSpace} that is of interest to the \textit{Client}.''~\cite{opcfoundation2017part1}

				\end{itemize}

				\begin{figure}[H]
					\centering
					\includegraphics[width=\textwidth]{opc_ua_server_model.jpg}
					\caption{The Open Platform Communications Unified Architecture server architecture adapted from~\cite{opcfoundation2017part1}}
					\label{fig:opc_ua_server_model}
				\end{figure}

			\subsection{OPC UA Client Model}\label{subsec:opc_ua_client_model}

				The \gls{opcua} Client architecture models the Client endpoint of client/server interactions.
				\Cref{fig:opc_ua_client_model} illustrates the major elements of a typical Client and how they relate to each other.
				As presented in~\cref{fig:opc_ua_client_model}, the \gls{opcua} Client is constructed by two layers -- the Client Application and the \gls{opcua} Client \gls{api}. The Client Application encapsulates the producer–consumer service functionality by accessing the underlying \gls{opcua} Client-\gls{api} following the asynchronous system designs described in~\cite{tanenbaum2007distributed}.
				
				Further, the Client Application is the code that implements the function of the Client.
				It uses the Client \gls{api} to send and receive \gls{opcua} Service requests and responses to the Server.
				The Services defined for \gls{opcua} are described in Clause 6.4 of~\cite{opcfoundation2017part4}.
				Note that the ``Client API'' is an internal interface that isolates the Client application code from an \gls{opcua} Communication Stack.
				
				The \gls{opcua} Communication Stack converts Client \gls{api} calls into Messages and sends them through the underlying communications entity to the Server at the request of the Client application.
				The \gls{opcua} Communication Stack also receives response and \textit{NotificationMessages} from the underlying communications entity and delivers them to the Client application through the Client \gls{api}.

				\begin{figure}[H]
					\centering
					\includegraphics[width=\textwidth]{opc_ua_client_model.jpg}
					\caption{The Open Platform Communications Unified Architecture client architecture adapted from~\cite{opcfoundation2017part1}}
					\label{fig:opc_ua_client_model}
				\end{figure}
			
		\section{Conclusion}\label{sec:foundations_conclusion}
		
			In this section a detailed introduction to the \gls{rnp} \gls{cm} platform has been provided. 
			The concepts of Cloud Computing and \gls{cm} used in the platform have been provided as well. 
			\gls{opcua} has been introduced as an emerging \gls{m2m} communication protocol and its Server and Client \gls{api}s and architectures have been described in more detail. 		

	\chapter{State of the Art}\label{ch:state_of_the_art}
	
		In this chapter this work covers the state-of-the-art concepts and technologies being used for the evaluation, implementation and integration of the \gls{poc}. \Cref{sec:spring_boot} introduces the Spring Boot framework for the \gls{java}~\cite{java2015} programming language. In \cref{sec:docker} the trending virtualization container technology Docker is highlighted. Finally, the \gls{rest} concept for \gls{api} design is covered by \cref{sec:rest}

		\section{Spring Boot}\label{sec:spring_boot}

			The \gls{soa} of the \gls{rnp} platform was realized using the \gls{java}~\cite{java2015} programming language in combination with the Spring Boot Framework\footnote{\url{https://projects.spring.io/spring-boot/}}. The framework provides enterprise ready and production based patterns and functionalities for building backend services in Cloud architectures. Spring Boot provides a common abstraction layer of database entities, repositories abstracting the underlying persistence layer, services implementing the business logic and \gls{rest} controller presenting the business logic as \gls{rest}-ful \gls{api} including the mapping of different data models like \gls{json} or \gls{xml} to \gls{java}~\cite{java2015} objects.
			
			Besides its clean architectural approach, Spring Boot provides standard enterprise pattern configurations for message broker, service discovery, performance and metrics tracing as well as custom web-server configurations with little to no configuration effort.

		\section{Docker and Docker Compose}\label{sec:docker}
		
			Docker\footnote{\url{https://www.docker.com/}} is an open source project providing a systematic way to automate the faster deployment of Linux applications inside portable containers~\cite{bernstein2014containers}. 
			Basically, Docker extends \gls{lxc} with a kernel-and application-level API that together run processes in isolation: \gls{cpu}, memory, disk read and write operations, network, and so on. 
			Docker also uses namespaces to completely isolate an application’s view of the underlying operating environment, including process trees, network, user identifiers, and file systems.
			Docker containers are created using base images.
			A Docker image can include just the \gls{os} fundamentals, or it can consist of a sophisticated prebuilt application stack ready for launch. 
			
			When building images with Docker, each action taken (that is, command executed, such as an installation of dependencies) forms a new layer on top of the previous one. 
			Commands can be executed manually or automatically using Dockerfiles.
			
			The difference between standard hypervisor virtualization and Docker containers is shown in \cref{fig:virtualization}.
			Each block, shown in~\cref{subfig:hypervisor} and~\cref{subfig:docker} describes a physical or software layer, of the virtualization process. 
			By referencing the hardware layer, this work refers to the underlying physical device either represented by a server or general computer. 
			The Host Operating system refers to the Operating System installed upon the underlying hardware architecture.
			In hypervisor-based virtualization, the hypervisor is a software product, installed upon the underlying hardware and host operating system, providing hardware, network and process protocol virtualization functionalities.
			The blocks in the first virtual machine described in~\cref{subfig:hypervisor} represents a virtualized computer, containing its own Operating System, binaries containing encapsulated system functionalities to run specific software of the Operating System and the Application as the piece of software to be run in the virtual machine.
			Analogously, these terms and symbols find their use in~\cref{subfig:docker}.
			
			\begin{figure}[H]
				\centering
				\begin{subfigure}{0.45\textwidth}
					\centering
					\includegraphics[width=0.9\linewidth]{virtual_hypervisor.jpg}
					\caption{A diagram showing the layers of a hzypervisor-based virtualization}
					\label{subfig:hypervisor}
				\end{subfigure}
				\hfill
				\begin{subfigure}{0.45\textwidth}
					\centering
					\includegraphics[width=0.9\linewidth]{virtual_docker.jpg}
					\caption{A diagram showing the layers of a Docker container virtualization}
					\label{subfig:docker}
				\end{subfigure}
				\caption{Diagrams showing hypervisor-based and Docker virtualization}
				\label{fig:virtualization}
			\end{figure}
			
			While standard virtualization builds each operating system itself, container rely only on the presence of the Docker Engine, encapsulating services in minimal environments.
			Docker Compose\footnote{https://docs.docker.com/compose/} is a tool for defining and running multi-container Docker applications. It offers configuration, management and orchestration utilities for container based or hybrid architectures. Further, Docker Compose can be used to deploy Docker containers and its services to different hosting environments by guaranteeing the same deployment and service architecture on each of the different environments.

		\section{Representional State Transfer}\label{sec:rest}

			\gls{rest} is a pattern of resource operations that has emerged as a \textit{de facto} standard for service design in Web 2.0 applications~\cite{battle2008bridging}. Whereas the traditional approaches to Web Services uses full-blown remote objects with remote method invocation and encapsulated functionality, \gls{rest} deals only with data structures and the transfer of their state~\cite{fielding2000architectural}.
			
			At the core of \gls{rest} based design is a set of state transfer operations universal to any data storage and retrieval system.
			These operations, as commonly interpreted on the web, are referred to by the acronym \gls{crud}~\cite{battle2008bridging}.
			The Web 2.0 community has adopted an informal mapping of \gls{crud} operations onto the commands provided by the \gls{http} protocol: POST, GET, PUT, and DELETE, respectively. 
			These commands identify the particular \gls{crud} operation being requested of the resource identified by the \gls{url} endpoint.
			\Cref{tab:http_rest_mapping} shows the mapping between \gls{rest} and the \gls{http} protocol.
			
			\begin{table}[!h]
				\centering
				\caption{Hypertext Transfer Protocol to Representational State Transfer Mapping}
				\label{tab:http_rest_mapping}
				\begin{tabular}{@{}llll@{}}
					\toprule
					\gls{crud} operations & \gls{http} command & Input format & Output format
					\\ \midrule
					Create & POST & \gls{http} Form Encoded & Status 201 CREATED
					\\ \midrule
					Read & GET & None & Determined by request headers 
					\\ \midrule
					Update & PUT & \gls{http} Form Encoded & Status 200 OK
					\\ \midrule
					Delete & DELETE & None & Status 200 OK
					\\ \bottomrule
				\end{tabular}
			\end{table}
		
		\section{Conclusion}\label{sec:state_of_the_art_conclusion}
			
			In this section State of the Art technologies and concepts have been introduced.
			Spring Boot and the Spring Framework have been presented as a widely adopted technology to build \gls{java} Services for \gls{soa} applications.
			Further, concepts and technologies to distribute applications and services over different platforms and underlying systems using container virtualization with Docker have been described as well.
			Finally, \gls{rest} has been described as a fundamental concept of modeling service \gls{api}s. 
			The mapping process of \gls{http} requests to the \gls{rest} model has been described as well.

	\chapter{State of Research} \label{ch:state_of_the_Science}

		This chapter highlights related research and work respective to this thesis. \Cref{sec:state_of_science_cloud_manufacturing} summarizes the current state of \gls{cm}. In \cref{sec:control_engineering_in_the_cloud} a brief overview is given over the state of Control Engineering from the cloud. This chapter is closed by providing information about the current research state on \gls{m2m} communication protocols in~\cref{sec:machine_to_machine_communication}.

		\section{State of Research in Cloud Manufacturing}\label{sec:state_of_science_cloud_manufacturing}

			As a new IT paradigm, Cloud Computing is being increasingly adopted to transform the way that \gls{it} resources are utilised and consumed~\cite{li2010cloud}. 
			Consequently, the manufacturing industry is exploring Cloud Computing in order to improve existing manufacturing structures and enterprise systems, to
			share and provide on-demand networked manufacturing services, and to better satisfy specific manufacturing enterprise needs~\cite{he2015state}.
			So far researchers have proposed a number of new techniques and approaches to encapsulate various virtualized manufacturing resources and capabilities as Cloud-based services and to implement enterprise \gls{cm} service frameworks and platforms~\cite{tao2011cloud}.
			
			But as the use of these new paradigms gets more and more common, challenges for \gls{cm} service models and production sites arise~\cite{brettel2014virtualization}.
			Networked manufacturing for example, lacks strong management mechanisms and efficient tools to coordinate large-scale distributed resources, services and operations~\cite{xu2012cloud}.
			
			Besides the lack of management and control mechanisms in \gls{cm} multivendor systems and heterogeneous infrastructure on production sites pose additional challenges on the \gls{cm} research field~\cite{weyer2015towards}.
			The specification of standard communication protocols and data models gains a fast growing role in the automation~\cite{jazdi2014cyber} and \gls{cm} field~\cite{wollschlaeger2017future}.
			
			Further, security gets more and more relevance in \gls{cm} field.
			In a traditional on-premise application deployment model, the sensitive data of each enterprise continues to reside within the enterprise boundary and is subject to its physical, logical and personnel security and access control policies~\cite{jeschke2017industrial}. 
			However, in the \gls{saas} model, the enterprise data is stored outside the enterprise boundary, at the \gls{saas} vendor end~\cite{subashini2011survey}.
			Consequently, the \gls{saas} vendor must adopt additional security checks to ensure data security and prevent breaches due to security vulnerabilities in the application or through malicious employees.

		\section{Control Engineering in the Cloud}\label{sec:control_engineering_in_the_cloud}

			As mentioned in~\cref{sec:state_of_science_cloud_manufacturing}, that with the emerging of Cloud Computing patterns in the manufacturing field, control engineers as well try to move their field of automation to the Cloud.
			As discussed in~\cite{jazdi2014cyber}, an approach that implements the concept of \gls{plc} in a \gls{xaas} manner was provided by their work. 
			The result presented in ~\cite{jazdi2014cyber} is a \gls{cps} including control over \gls{plc}s, implementing concepts of Cloud Computing and provided using the Cloud Computing service models. 
			Not taking performance and real-time computing requirements into account, this paper shows that a shift to the Cloud in the automation field can be realized.
			
			Another research project which has automation and control using \gls{plc}s as a focus is the project piCASSO currently researched at the \gls{isw}~\cite{kretschmer2016communication}.
			Its goal is the auto-provisioning \gls{cps} to manufacturing sites.
			A platform based on a \gls{soa}, which coordinates a robot remotely through the Cloud, has been presented in~\cite{kretschmer2016communication}. 
			Showing different approaches of networking in the automation field, the results several new points of interest to researchers in this field.

		\section{Machine-to-Machine Communication}\label{sec:machine_to_machine_communication}
			
			Many \gls{cps} are sensor-rich distributed real-time embedded systems that closely interact with the physical world~\cite{kang2012rdds}. 
			In such systems, numerous entities cooperate with each other to achieve their common goals. 
			They collect data from the physical world using sensors and feed the sensor data into computing resources, which in turn make real-time decisions in cooperation by sharing data and information among participating entities.
			
			In the context of \gls{cm} and control engineering from the Cloud, researchers focus on the definition of standard \gls{m2m} communication protocols tackling on exactly these problems.
			Respectively, two protocols emerged for the manufacturing field trying to fulfill the needs of manufacturers; \gls{opcua} and \gls{dds}~\cite{jazdi2014cyber}.
			While \gls{opcua} is largely adapted by European manufacturers, \gls{dds} is more popular at manufacturers in the United States~\cite{schleipen2008opc}.
			\gls{opcua} builds a whole abstraction model containing, communication and data structures~\cite{candido2010soa}.
			\gls{dds} on the other hand offers a more simple and unopinionated model provided by an object definition and abstraction model~\cite{candido2010soa}.
			
			As described in~\cref{sec:opc_ua}, \gls{opcua} serves an abstraction layer for \gls{m2m} communication. Using \gls{opcua}, attempts have been taken to implement a \gls{soa} middleware for control engineering from the Cloud~\cite{melik2012towards}.
			However, these several attempts for implementing \gls{soa}-based Automation Systems have been implemented successfully, but always with non-industrial, non-standard software like Devices Profile for Web Services~\cite{melik2012towards}.
			Of great interest for research is the connection and integration of production sites via \gls{opcua}, which does not require a manufacturer-specific solution~\cite{melik2012towards}. These integrations should follow the \gls{opcua} model principles and rely on the specified standard implementation, ensuring a seamless integration of different manufacturing tools and units into a \gls{soa} middleware solution~\cite{imtiaz2013scalability}.
			
		\section{Conclusion}\label{sec:state_of_the_research_conclusion}
		
			Text
			
	\chapter{Evaluation}\label{ch:evaluation}
	
		In this chapter, the evaluation of an appropriate \gls{opcua} framework for the \gls{poc} implementation is provided. \Cref{sec:evaluation_requirements} describes the requirements elaborated that should be met by the framework. 
		Using the defined requirements, a decision about the framework is made in~\cref{sec:evaluation_decision}.
		
		\section{Requirements}\label{sec:evaluation_requirements}
		
			This section will discuss the elaboration process of requirements and their definition, finally upon which a decision about which \gls{opcua} framework should be used in the \gls{poc} to implemented as part of this work. 
			It should be mentioned that functional and non-functional requirements are not separated in this decision process.
			
			\paragraph{Licensing} Following the motivation and goals defined in~\cref{sec:motivation,sec:goals}, this work wants to provide an architectural approach and implement a \gls{poc} based on Open Source technologies.
			Thus, a requirement for the \gls{opcua} framework to be chosen is, that it should be licensed under an Open Source License like the Apache V2 License\footnote{\url{https://www.apache.org/licenses/LICENSE-2.0}}.
			
			\paragraph{Specification Compliance} First and foremost, \gls{opcua} is a specification of an \gls{m2m} communication protocol and a corresponding architecture to establish this communication. 
			As a result \gls{opcua} does not specify a specific programming language, neither the level of accuracy a possible specification implementation should support. 
			This leads to the fact, that the \gls{opcua} framework chosen in this work, should be as accurate as possible in the implementation of the specification to guarantee, that all basic \gls{opcua} functionalities can be used and tested in the implemented \gls{poc}. 
			Therefore, the investigated frameworks should be checked for the degree of \gls{opcua} specification compliance.
			
			\paragraph{Separation of Concerns} Following the principle of the separation of concerns described in~\cite{hursch1995separation}, the \gls{opcua} framework should be split into Client and Server \gls{api}s.
			This should be given because this work aims to implement a machine-tool and \gls{opcua} Server \gls{api} independent \gls{poc}, so the functionalities for the Server \gls{api} are not required for the \gls{poc} and would only overload the \gls{poc}.
			
			\paragraph{Programming Language Support} As this work aims to provide a concept for an \gls{poc}, which should be adaptable to different \gls{cm} platforms, the chosen framework should ideally be available for different programming languages. 
			For the sake of this work, the focus will be set only on the following programming languages: \gls{java}\footnote{\url{https://docs.oracle.com/javase/specs/jls/se8/html/index.html}}, \gls{ccpp}\footnote{\url{https://www.iso.org/standard/68564.html}}, \gls{cs}\footnote{\url{https://docs.microsoft.com/de-de/dotnet/csharp/}}, \gls{python}\footnote{\url{https://docs.python.org/3/}}, \gls{nodejs}\footnote{\url{https://nodejs.org/dist/latest-v10.x/docs/api/}} and the \gls{golang}\footnote{\url{https://golang.org/ref/spec}}.
			These programming languages have been chosen as they are the most common programming languages adopted for backend applications according to~\cite{jain2017evolution}.
			
			The \gls{java} programming language is further defined mandatory because all backend services of the \gls{rnp} platform are programmed using the \gls{java} programming language.
			This fact is described in detail in~\cref{subsec:services}.
			
			\paragraph{Level of Abstraction} The presentation of an abstract concept for the implementation of a proof-of-concept is the overarching goal of this work. 
			Therefore, the framework should abstract the underlying \gls{opcua} Client \gls{api} functionalities into bundled logical modules. 
			This should serve two requirements: easing of the \gls{poc} development process by the same time  keeping the implemented service maintainable as well as to provide a proof, that the suggested \gls{poc} is generic enough not to relying directly on \gls{opcua} Client \gls{api} base functionalities. 
			To analyze this more abstract requirement, the frameworks will be compared to the example specification implementation of the \gls{opc} Foundation\footnote{\url{https://github.com/OPCFoundation/UA-Java}}. 
			
			\paragraph{Industrial and Community Support} The last requirement is to examine the frameworks to see if they already have industrial application in the control and automation environment.
			Furthermore, the Open Source frameworks should be checked for the activity of their developer community, as this software does not have to undergo regular updates under maintenance contracts and because future work must be able to continue working with the proposed methodology. To measure this requirement, general activity and commit frequency in the public versioning systems of the frameworks will be measured as well as the general response time on new issues.
			
		\section{Decision}\label{sec:evaluation_decision}
		
			Taking the requirements defined in~\cref{sec:evaluation_requirements}, this section analyzes \gls{opcua} frameworks and decides one to be used in the \gls{poc} implementation. In this section, the chosen frameworks will be analyzed against the requirements defined in~\cref{sec:evaluation_requirements}. The results will be presented in~\cref{tab:framework_comparison} using Harvey Balls. 
			A full Harvey Ball~\harveyBallFull~will show, that a requirement has totally been met.
			If requirements have not been met in full or not at all, these results are represented by the following Harvey Balls in descending order: \harveyBallThreeQuarter, \harveyBallHalf, \harveyBallQuarter~and \harveyBallNone.
			
			The following frameworks have been selected for comparison by the first 32 results of a DuckDuckGo Search\footnote{\url{https://duckduckgo.com/}} result for the search query "\texttt{opc ua framework java}" (this search query was last checked on January 31, 2018):
			
			\begin{enumerate}
				
				\item \gls{opc} Foundation UA-\gls{java}\footnote{\url{https://github.com/OPCFoundation/UA-Java}} - the example implementation in \gls{java} implemented by the \gls{opc} Foundation.
				
				\item PLCcom \gls{opcua} SDK\footnote{\url{https://www.plccom.de/produkte/opc/opc-ua-client-sdks.html}} - a commercial \gls{java} \gls{sdk} for \gls{opcua} Server and Client implementations supporting \gls{cs} as well.
				
				\item Ascolab UA \gls{java} SDK\footnote{\url{http://www.ascolab.com/en/technology-unified-architecture/technology-implementations.html}} - a commercial \gls{java} \gls{sdk} for general \gls{opcua} implementations, supporting \gls{ccpp} and \gls{cs} as well.
				
				\item opcua4j\footnote{\url{https://code.google.com/archive/p/opcua4j/}} - an Open Source implementation of the \gls{opcua} Server specification in \gls{java}.
				
				\item Prosys \gls{opcua} \gls{java} SDK\footnote{\url{https://code.google.com/archive/p/opcua4j/}} - a proprietary \gls{java} \gls{sdk} for \gls{opcua} compliant \gls{opcua} Server and Client implementations.
				
				\item Unified Automation UA \gls{java} SDK\footnote{\url{https://www.unified-automation.com/products/client-sdk/java-ua-client-sdk.html}} - a proprietary \gls{java} \gls{sdk} for \gls{opcua} compliant \gls{opcua} Server and Client implementations, supporting \gls{ccpp} and \gls{cs} as well.
				
				\item Eclipse Milo\footnote{\url{https://github.com/eclipse/milo}} - an Open Source \gls{java} library totally compliant to the \gls{opcua} specification separated into \gls{opcua} Client and Server \gls{sdk}s and supported by industrial partners as well as by an active community.
				
			\end{enumerate}
			
			After the frameworks were found, each of them was checked against the requirements defined in~\cref{sec:evaluation_requirements}. The results of the evaluation are presented in~\cref{tab:framework_comparison}. In the License column, only an empty or a full Harvey Ball could be given, as the requirement is, whether the framework is Open Source or not.
			
			Regarding the compliance to the specification a half Harvey Ball was given, if the framework implements only one of the both \gls{opcua} \gls{api}s; either the Server \gls{api} or the Client \gls{api}.
			In the column representing the results for the Separation of Concerns requirements, the results were notated with an empty Harvey Ball if the \gls{sdk} has been implemented in a monolith architecture containing both, Server and Client \gls{opcua} \gls{api}s. If the \gls{api}s have been separated into two or more different \gls{sdk}s, a full Harvey Ball was given as the requirement was totally met.
			
			Results for the support of different programming languages were annotated with a quarter Harvery Ball if the framework is only implemented for the \gls{java} programming language and for each further supported programming language the Harvey Ball was filled a quarter step fuller.
			The decision concerning the level of abstraction away from the basic \gls{opcua} \gls{api}, was tested by the way, how a test client implemented with the framework, can be connected to a \gls{opcua} Server. Method and function calls of the native \gls{opcua} Client \gls{api} have been annotated with a quarter Harvey Ball and a full Harvey Ball was given if the framework abstracts the \gls{opcua} functionalities by providing dedicated methods for each operation and abstracting the underlying protocol and handling.
			
			Finally, for the support of the development community and the industrial support for the framework development, a quarter Harvey Ball was given if the framework is only implemented by the company or the community reaction time is about two weeks (as seen for a not handled issue by the opcua4j framework for about 2 months). Further, a half Harvey Ball was given for an active industrial development of the framework, followed by an additionally active but not responsive open developer community and concluding to a full Harvey Ball if the framework is developed by an active Open Source community and the development is actively supported by the industry. 
			
			In~\cref{tab:framework_comparison} the requirements defined in~\cref{sec:evaluation_requirements} are abbreviated as follows: Licensing with \textit{Lic}, Specification Compliance with \textit{SC}, Separation of Concerns with \textit{SoC}, Programming Language Support with \textit{PLS}, Level of Abstraction with \textit{LoA} and Industrial and Community Support with \textit{ICS}.
			
			\begin{table}[!h]
				\centering
				\caption{Comparison of Open Platform Communications Unified Architecture Frameworks}
				\label{tab:framework_comparison}
				\begin{tabular}{l c c c c c c}
					\toprule
					Framework & Lic & SC & SoC & PLS & LoA & ICS
					\\ \midrule
					\gls{opc} Foundation UA-\gls{java} & \harveyBallFull & \harveyBallFull & \harveyBallNone & \harveyBallQuarter & \harveyBallQuarter & \harveyBallFull
					\\ \midrule
					PLCcom \gls{opcua} SDK & \harveyBallNone & \harveyBallFull & \harveyBallFull & \harveyBallHalf & \harveyBallFull & \harveyBallFull
					\\ \midrule
					Ascolab UA \gls{java} SDK & \harveyBallNone & \harveyBallFull & \harveyBallNone & \harveyBallThreeQuarter & \harveyBallFull & \harveyBallHalf
					\\ \midrule
					opcua4j & \harveyBallFull & \harveyBallHalf & \harveyBallNone & \harveyBallQuarter & \harveyBallQuarter & \harveyBallQuarter
					\\ \midrule
					Prosys \gls{opcua} \gls{java} SDK & \harveyBallNone & \harveyBallFull & \harveyBallFull & \harveyBallQuarter & \harveyBallFull & \harveyBallHalf
					\\ \midrule
					Unified Automation UA \gls{java} SDK & \harveyBallNone & \harveyBallFull & \harveyBallFull & \harveyBallThreeQuarter & \harveyBallFull & \harveyBallHalf
					\\ \midrule
					Eclipse Milo & \harveyBallFull & \harveyBallFull & \harveyBallFull & \harveyBallQuarter & \harveyBallFull & \harveyBallFull
					\\ \bottomrule
				\end{tabular}
			\end{table}
		
			After filtering~\cref{tab:framework_comparison} for the requirement, that the framework must be Open Source, only the \gls{opc} Foundation, the Eclipse Milo framework and opcua4j were left. As opcua4j only implements the \gls{opcua} Server \gls{api}, just the first both passed the second column of the requirements table. As the example implementation of the \gls{opc} Foundation only relies on native \gls{opcua} \gls{api} calls, the Eclipse Milo framework has been chosen as it provides a higher layer of abstraction making the \gls{poc} developed with it more understandable and maintainable.
			
		\section{Conclusion}\label{sec:evaluation_conclusion}
		
			In this chapter requirements for the decision process of an \gls{opcua} framework to be used for the implementation of the \gls{poc} in this work, have been defined. 
			These requirements have been checked against beforehand researched \gls{opcua} frameworks and results haven been presented in~\cref{tab:framework_comparison} using Havey Balls.
			The decision to utilize the Eclipse Milo Open Source framework for the \gls{poc} implementation has been made, since the framework implements the full \gls{opcua} Server and Client \gls{api} specifications and is actively supported by industrial partners.

	\chapter{Concept} \label{ch:concept}

		This chapter will describe the concept of the \gls{poc} to be integrated to \gls{rnp}.
		\Cref{sec:requirements} discusses and list requirements for the infrastructure and architecture of the platform, the technology decisions taken for the \gls{poc} implementation as well as mandatory and optional features. In \Cref{sec:approach} will highlight the implementation approach of the \gls{poc} highlighting the way the service has been integrated into the platform.

		\section{Requirements} \label{sec:requirements}

			In this section summarizes and give an overview over the requirements, gathered from the analysis of the \gls{rnp} platform and the discussion with the research partners.
			\Cref{subsec:infrastructure} will draw out the infrastructural requirements set on this work and the kind of deployment processes targeted.
			In \cref{subsec:architecture} the architecture will be discussed into which the \gls{poc} should be integrated following by \cref{subsec:technology} which describes the technologies to use for the implementation and integration.
			With \cref{subsec:mandatory} and \cref{subsec:optional} this chapter will be concluded by providing mandatory and optional Use Cases for this work.

			\subsection{Infrastructure} \label{subsec:infrastructure}

				In \Cref{sec:rent_n_produce} it has been described, that the \gls{rnp} platform is built upon services following the \gls{soa} approach, where each of the services takes responsibility for one specific domain task.
				Further, every service is separated into a business logic component serving the \gls{api} for its functionality, and a persistence layer component implemented either as a \gls{sql} or \gls{nosql} database.
				Following this pattern, this work deduces that the requirement will be to implement the \gls{poc} as a service, which stores the machine tool configuration data as well as the \gls{gcode} for the production part in a database and serves its \gls{api} over a service layer component.
				Further, both components will be realized using Docker containers.
				The business logic container will register itself to the service discovery component and be routed over the \gls{api} gateway.

			\subsection{Architecture} \label{subsec:architecture}

				As shown in \Cref{subsec:infrastructure} the \gls{poc} to be realized will be packaged into a Docker container and its functionality will be split up into a persistence layer and a business logic layer.
				As the machine tool integration represents a part of the resource service process, it doesn't need a \gls{ui} integration, as this part is already implemented in the \gls{rnp} architecture.

				More precise -- the \gls{poc} should implement an \gls{api}, which can be requested from the resource service, to trigger the production of the required parts contained in a customer order.

			\subsection{Technology} \label{subsec:technology}

				A core requirement to the \gls{poc} is the support of the \gls{opcua} protocol.
				Over \gls{opcua} the \gls{poc} should communicate with the machine tools already registered in the resource service of the platform.
				Second requirement is the filtering and recognition of \gls{gcode} data as it will be transferred to the \gls{plc} of the machine tool.
				For the integration to \gls{rnp}, the service should support the communication of \gls{json} over \gls{http} as well as the interaction with the service discovery server and the \gls{api} gateway.

			\subsection{Mandatory Features} \label{subsec:mandatory}

				As result of this work, a \gls{poc} should be implemented and integrated into the \gls{rnp} platform, so machine tools can be controlled over the Cloud platform.
				Therefore, a possibility is required to transfer \gls{gcode} data to the platform and from the platform down to the machine tools already provisioned.
				Finally, the possibility to trigger the start or the stop of a part production manually or automatically by the main production process is as well wanted. \Cref{fig:use_cases} lists the emerged Use Cases and shows their relation to each other following the \gls{uml} syntax and semantic described in~\cite{uml2017}.

				\begin{figure}[H]
					\centering
					\includegraphics[width=\textwidth]{use-cases.jpg}
					\caption{The Use Case diagram for the Proof-of-Concept}
					\label{fig:use_cases}
				\end{figure}

				The following~\cref{tab:use_case_upload,tab:use_case_check_machine,tab:use_case_transfer_code,tab:use_case_production_control}) will describe the Use Case definitions for the ones shown in \cref{fig:use_cases}.
				After the definition of the Preconditions for the given Use Case, an ordered description is following, by indicating the order of execution on the left side of the performing actors' description.
				The descriptions include only the regular process flow, as the side effects are described in more detail in the specification, created during this research work. This work will highlight, that the definition of the Use Cases to start and stop the tool production have been united into the Use Case of the general part production as the steps are identically and only change in the control signal sent to the machine tool. Further, the exception and error handling of these both Use Cases is exactly the same, as in the general part production.
				
				To start the manufacturing process of the production of a specific part, \gls{gcode} generated through a \gls{cad}-\gls{cam} chain by the user has to be uploaded to the Machine Client Service. \Cref{tab:use_case_upload} shows the Use Case description for this vendor task. The Upload is initiated through an \gls{http}-POST \gls{api} call to the service, which then persists the \gls{gcode} and the machine tool configurations to its database, returning a success message in form of an \gls{http} 200 OK response to the vendor or services in general, calling the service \gls{api}.
				After \gls{gcode} has successfully been uploaded to the platform, \cref{tab:use_case_check_machine} describes the check of the machine tool status for further manufacturing processes. The check is described more abstract, as every supported call \gls{opcua} \gls{api} could be transmitted down to the machine. 
				
				By positive response on the machine tool status, the \gls{poc} can now proceed with the transfer of \gls{gcode} down to a connected machine tool for following part production. The transfer described in~\cref{tab:use_case_transfer_code} shows the specific roles and actors in the transfer. The \gls{gcode} is transferred to the machine tool, by opening a \textit{UA\_FileType} on the machine tools \gls{opcua} Server, writing the persisted \gls{gcode} on the client-side to the opened file and closing the writing process by linking the new \textit{UA\_Object} respectively with its surrounding \textit{AddressSpace}.
				Finally, when all prerequisites are met (the machine tool status was checked and the machine tool is available, \gls{gcode} has been persisted to the platform and transferred down to the machine tool), the \gls{poc} can start the (or stop an already running) part production as presented in~\cref{tab:use_case_production_control}. Here, the preconditions need to be met are summarized, as well as the way, how \gls{gcode} production has to be started on the machine tool.
				
				\begin{table}[htbp]
					\centering
					\caption{Use Case description for the upload of production data}
					\label{tab:use_case_upload}
					\newcolumntype{L}{>{\centering\arraybackslash} m{.2\linewidth} }
					\newcolumntype{R}{>{\arraybackslash} m{.7\linewidth} }
					\begin{tabular}{L R}%{c c}
					% \begin{tabular}{l p{11cm}}
						\toprule
						Name & Upload \gls{gcode}
						\\ \midrule
						Identifier & /UC-10/
						\\ \midrule
						Description & The vendor converted his \gls{cad} files into \gls{gcode}, so they can be transferred to the machine tool.
						\\ \midrule
						Actors & \begin{enumerate}\item A \gls{rnp} platform user with the vendor role. \item The \gls{opcua} Client Service.\end{enumerate}
						\\ \midrule
						Trigger & The vendor has prepared the \gls{gcode} and wants to transfer it to the machine tool.
						\\ \midrule
						Level & User-View
						\\ \midrule
						Invariants & \begin{enumerate}\item The user stays logged in and keeps his OAuth2-Token with the appropriate scope. \item The uploaded files have not been changed in format, type or content.\end{enumerate}
						\\ \midrule
						Preconditions &
						\begin{enumerate}
							\item The user is already logged in to the system using his web-browser and his session is assigned with an OAuth2 Token including the scopes \textit{user}, \textit{customer} and \textit{vendor}.
							\item The user has the \gls{gcode} to be uploaded.
							\item The \gls{gcode} has the MIME-Type \textit{application/x-netcdf}.
							\item The user knows the identifier for the order, the \gls{gcode} is for.
						\end{enumerate}
						\\ \midrule
						\begin{tabular}{c c} 1 & User \end{tabular} & The user uploads the \gls{gcode} using an HTTP-POST request to the \gls{opcua} Client Service.
						\\ \midrule
						\begin{tabular}{c c} 2 & System \end{tabular} & The systems persists the \gls{gcode} categorized under its order identifier and responds to the user with an HTTP-201 CREATED response containing order identifier and the production part identifier.
						\\ \midrule
						Postconditions & The \gls{gcode} has been persisted to the system. From the technical point of view, the service responds with an HTTP-201 CREATED Status. The user can download the file over the same \gls{api} by providing the production part id. The \gls{gcode} file has not been manipulated after the upload.
						\\ \bottomrule
					\end{tabular}
				\end{table}
			
				\begin{table}[htbp]
					\centering
					\caption{Use Case description for the retrieval of the current machine tool status}
					\label{tab:use_case_check_machine}
					\newcolumntype{L}{>{\centering\arraybackslash} m{.3\linewidth} }
					\newcolumntype{R}{>{\arraybackslash} m{.6\linewidth} }
					\begin{tabular}{L R}%{c c}
					% \begin{tabular}{l p{9cm}}
						\toprule
						Name & Request machine tool status
						\\ \midrule
						Identifier & /UC-20/
						\\ \midrule
						Description & The service is able to request the current status of the machine tool using the \gls{opcua} protocol. The service should only request, if a machine tool is prepared for production and does not deliver any error states.
						\\ \midrule
						Actors & \begin{enumerate}\item The \gls{opcua} Client Service. \item The machine tool to be requested.\end{enumerate}
						\\ \midrule
						Trigger & Use Cases including this Use Case have been triggered as shown in~\cref{fig:use_cases}.
						\\ \midrule
						Level & Technical View
						\\ \midrule
						Invariants & This Use Case describes only the retrieval of \gls{opcua} specific information. As long as the protocol and correction are correct, this Use Case doesn't have any invariants.
						\\ \midrule
						Preconditions &
						\begin{enumerate}
							\item The \gls{opcua} Client Service established and holds a connection to the \gls{opcua} server of the machine tool.
							\item The machine tool is available over Ethernet and \gls{opcua}.
						\end{enumerate}
						\\ \midrule
						\begin{tabular}{c c} 1 & \gls{opcua} Client Service \end{tabular} & The \gls{opcua} Client Service requests one of the states from the machine tool: \begin{enumerate}
							\item Is the machine tool currently in an error state?
							\item Is the machine tool ready to produce a part (e.g., material preparared and machine tool loaded)?
							\item Is the machine tool currently producing a part?
						\end{enumerate}
						\\ \midrule
						\begin{tabular}{c c} 2 & Machine-Tool \end{tabular} & The \gls{opcua} Server of the machine tool responds to the requests of the client service.
						\\ \midrule
						Postconditions & The \gls{opcua} Client Service gathered the requested data from the machine tool. This data can now be used for further production process steps.
						\\ \bottomrule
					\end{tabular}
				\end{table}

				\begin{table}[htbp]
					\centering
					\caption{Use Case description for transfer of production data to the machine tool}
					\label{tab:use_case_transfer_code}
					\newcolumntype{L}{>{\centering\arraybackslash} m{.3\linewidth} }
					\newcolumntype{R}{>{\arraybackslash} m{.6\linewidth} }
					\begin{tabular}{L R}%{c c}
					% \begin{tabular}{l p{10cm}}
						\toprule
						Name & Transfer \gls{gcode} to a Machine-Tool
						\\ \midrule
						Identifier & /UC-21/
						\\ \midrule
						Description & The vendor can transfer previously uploaded \gls{gcode} (as described in \cref{tab:use_case_upload}) to the machine tool.
						\\ \midrule
						Actors & A \gls{rnp} platform user with the vendor role, the \gls{opcua} Client Service and the machine tool the data should be transferred to.
						\\ \midrule
						Trigger & The vendor has uploaded \gls{gcode} to the system and wants to transfer it to a machine tool.
						\\ \midrule
						Level & User-View
						\\ \midrule
						Invariants & The transferred \gls{gcode} stays persisted in the database and will not be modified. The transferred data doesn't override data already existing on the machine tool control units.
						\\ \midrule
						Preconditions & The user is already logged in to the system using his web-browser and his session is assigned with an OAuth2 Token including the scopes \textit{user}, \textit{customer} and \textit{vendor}. \gls{gcode} has been transferred as described in~\cref{tab:use_case_upload}.
						\\ \midrule
						\begin{tabular}{c c} 1 & User \end{tabular} & The user requests the Client-Service with an HTTP-POST method containing the identifiers of the part to be produced and the producing machine tool.
						\\ \midrule
						\begin{tabular}{c c} 2 & System \end{tabular} & The Client-Service checks the requested machine tool for its current state as described in~\cref{tab:use_case_check_machine}.
						\\ \midrule
						\begin{tabular}{c c} 3 & System \end{tabular} & The Client-Service loads the \gls{gcode} for the part from the database.
						\\ \midrule
						\begin{tabular}{c c} 4 & System \end{tabular} & The Client-Service creates an \gls{opcua} connection with the Server on the machine tool and sends the \gls{gcode} data.
						\\ \midrule
						\begin{tabular}{c c} 5 & The Machine-Tool \end{tabular} & The \gls{opcua} Server on the machine tool receives the request, and stores the \gls{gcode} in the AddressSpace to a new file and loads it to the \gls{nc} of the machine tool. Finally, a response, that the persistence was successful is sent back to the Client-Service.
						\\ \midrule
						\begin{tabular}{c c} 6 & System \end{tabular} & The Client-Service informs the user, that the transfer was successful by responding with an HTTP-200 OK status.
						\\ \midrule
						Postconditions & The \gls{gcode} has been transferred to the machine tool and into its \gls{nc}. The user is informed that the transfer was successful and the user can continue the usage of the platform. \gls{gcode} is now a new File in the \gls{opcua} name space and can be used to produce the part.
						\\ \bottomrule
					\end{tabular}
				\end{table}

	\newpage

				\begin{table}[htbp]
					\centering
					\caption{Use Case description for the production control of the machine tool}
					\label{tab:use_case_production_control}
					\newcolumntype{L}{>{\centering\arraybackslash} m{.3\linewidth} }
					\newcolumntype{R}{>{\arraybackslash} m{.6\linewidth} }
					\begin{tabular}{L R}%{c c}
					% \begin{tabular}{l p{9cm}}
						\toprule
						Name & Start and Stop a part production
						\\ \midrule
						Identifier & /UC-22/
						\\ \midrule
						Description & \gls{gcode} data has been successfully transferred to a machine tool. This \gls{gcode} should now be run to produce a part.
						\\ \midrule
						Actors & The \gls{opcua} Client-Service of the \gls{rnp} platform, as well as the control composite of the \gls{opcua} Server, the \gls{plc} and \gls{nc} of the machine tool as the second actor.
						\\ \midrule
						Trigger & \gls{gcode} has been transferred to the machine tool and now the part production should either be started or stopped.
						\\ \midrule
						Level & Technical View
						\\ \midrule
						Invariants & The \gls{gcode} transferred to the machine tool stays in the same location of the \gls{plc} and \gls{nc} after the production is started or stopped. The machine tool stays connected to the \gls{rnp} platform during the whole process.
						\\ \midrule
						Preconditions & The \gls{gcode} was properly transferred to the machine tool as described in~\cref{tab:use_case_upload}. The \gls{opcua} Server and the machine itself are connected with the \gls{rnp} platform. The machine tool is not in an error state as described in~\cref{tab:use_case_check_machine}.
						\\ \midrule
						\begin{tabular}{c c} 1 & \gls{opcua} Client-Service \end{tabular} & The Client-Service triggers the start or the stop of the production.
						\\ \midrule
						\begin{tabular}{c c} 2 & The machine tool \end{tabular} & The machine tool loads the \gls{gcode} and produces the part or stops its current production, not going into an error state.
						\\ \midrule
						\begin{tabular}{c c} 3 & \gls{opcua} Server \end{tabular} & The server registers the processes of the machine tool and sends it to the message broker of the \gls{rnp} platform over a response to the \gls{opcua} Client-Service of the platform.
						\\ \midrule
						Postconditions & The part has been produced or the production process of the machine tool has been stopped. The current state of the machine tool can be monitored over the \gls{opcua} Client-Service of the \gls{rnp} platform.
						\\ \bottomrule
					\end{tabular}
				\end{table}
			
	\newpage

			\subsection{Optional Use Cases} \label{subsec:optional}

				Besides the requirements defined to validate the \gls{poc} created in this work, several optional Use Cases are defined as well to extend the capacity of the \gls{poc} which could be implemented during this work, or providing inspiration for future research on this matter.
				The optional Use Cases pointed out during the research phase are described below in hastily manner giving space for requirement changes and other input and ideas coming from future research:

				\begin{enumerate}

					\item More than the control over the \gls{opcua} Client-Service of the \gls{rnp} platform developed during this work, one could image to transfer signals in form of visual information to the \gls{hmi} of the machine tool. With this Use Case, workers at the production site of the machine tool are give the possibility to interact with the system and visually monitor the current state of the whole manufacturing process.

					\item At the state of this research, the machine tool will be integrated only by pre configured data from the manufacturing. 
					Allowing an auto-provisioning of the machine tools could increase the productivity of manufacturers and create a very homogeneous production environment.

					\item One could imagine, that it could be useful to attach a monitoring or machine learning component to the service to be implemented. With a Big Data approach the created \gls{poc} could deliver more insights on the machine to the manufacturer increasing productivity and the whole manufacturing site performance.

				\end{enumerate}

		\section{Approach} \label{sec:approach}

			With the requirements pointed out in \cref{sec:requirements} this work will now present the approach used to implement and integrate the desired \gls{poc} into the \gls{rnp} platform. Using the defined requirements and Use Cases in \cref{sec:requirements} as well as relying on the research foundations highlighted in \cref{ch:foundations}, the \gls{poc} will be tested against these. The developed \gls{poc} should be a service, independent of the \gls{rnp} platform to ensure a possible use on every \gls{cm} platform working with the \gls{opcua} protocol.

			\subsection{Integration} \label{subsec:integration}

				As distilled from the platform analysis and defined in the requirements, the \gls{poc} will be packaged as a service, following the \gls{soa} principles into two Docker virtualization containers. One container will contain the business logic of the \gls{poc} and serve its \gls{rest}-ful \gls{api}. A second container will serve the \gls{sql} database using PostgreSQL\footnote{\url{https://www.postgresql.org/}} as the \gls{rdbms}.
				The \gls{poc} itself will communicate with the \gls{rnp} platform by registering itself to the service discovery of the platform and being routable through the \gls{api} gateway already implemented as the edge entry point of the platform.
				The binding with the machine tool for the \gls{poc} will be done using an external \gls{url} of the \gls{opcua} Server of the machine tool.

			\subsection{Target Architecture} \label{subsec:target_architecture}

				As shown in \cref{fig:poc_integration_diagram}, the \gls{uml} Component Diagram shows the \gls{poc}, which offers an \gls{api} to the \gls{rnp} platform to gather data and control the bound machine tool following the approach described in \cref{subsec:integration}. The component diagram following the \gls{uml} syntax and semantic described in~\cite{uml2017}, shows that by adapting the \gls{soa} architecture of the \gls{rnp} platform, the service can be integrated
				seamlessly. 
				The \gls{opcua} Service encapsulates the \gls{opcua} functionalities into a single component, offering its \gls{api} to interested \gls{rnp} services. 
				The machine tool is bound to the Cloud platform only by its \gls{opcua} Server.

				\begin{figure}[H]
					\centering
					\includegraphics[width=\textwidth]{poc_integration_diagram.jpg}
					\caption{The component diagram of the integration of the Proof-of-Concept}
					\label{fig:poc_integration_diagram}
				\end{figure}

				As presented in \cref{fig:poc_integration_diagram} \gls{poc} service communicates with and controls the machine tool only addressing its \gls{opcua} server. The machine tool itself can be abstracted into three sub components: the \gls{opcua} server running on the controlling industrial computer attached to the physical machine tool, the \gls{plc} and the \gls{nc} as physical parts of the machine tool.

				The \gls{opcua} Server receives client requests and commands and transfers them to the \gls{plc} unit of the machine tool. This abstraction layer ensures, that standard requests and commands sent to the server, can be translated without the knowledge of the Client of specific machine tool configurations.
				By this approach this work refers to the research target of this work, to implement a machine tool independent solution as gathered from the research described in~\cref{sec:machine_to_machine_communication}.

				The \gls{plc} of the machine tool is responsible for the physical and electrical control of the manufacturing and machine tool processes. It can execute control commands like data gathering from the machine tool state, start- and stop of the production and transfer data to the \gls{nc}. Processing of production parts data, planing of the milling routes for example and executing the part production is handled by the \gls{nc}. Production data is loaded from and to the \gls{nc} via the \gls{plc} and the current state is transferred to the \gls{plc} in real-time ensuring a correct monitoring of every production process.

				Making use of the \gls{opcua} specification, the \gls{poc} and the machine tool can be integrated without adding too much of abstraction layers keeping the architecture clean, understandable and maintainable without loads of effort.

			\subsection{Services} \label{subsec:services}

				After describing the high level integration process, the services and \gls{api}s provided by the \gls{poc} will be highlighted in this section. \cref{fig:poc_service_diagram} shows out of which services and what kind of services, the \gls{poc} will be implemented. The contenct presented in~\cref{fig:poc_service_diagram} is described using a \gls{uml} Component Diagram following~\cite{uml2017}.
				
				Each part of the functionality will be bound into a four tier composite -- the Entity representation of the domain specific objects to be persisted to the database, a Repository layer making database queries available using the Spring Boot \gls{jpa} of the Entity, a Service layer implementing the business logic of the specific functionality and finally a Spring Boot \gls{rest} Controller wrapping the Service layer functionality into a \gls{rest}-ful \gls{api} also handling the mapping of \gls{json} objects to \gls{java}~\cite{java2015} Entities.

				\begin{figure}[H]
					\centering
					\includegraphics[width=\textwidth]{poc_services.jpg}
					\caption{The component diagram describing service details of the Proof-of-Concept}
					\label{fig:poc_service_diagram}
				\end{figure}

				On the left side of \cref{fig:poc_service_diagram} the described blocks serving the \gls{api}s to persist, retrieve and manipulate data of the production part and machine tool domain entities are presented. These \gls{api}s are responsible for persisting new machnine-tools and configurations to the system as well as the persistence of the parts to be produced with their \gls{gcode} data and production dates to allow automatically or manual scheduling of the production processes. As the Service Discovery and the \gls{api} gateway of the \gls{rnp} produce are tightly bound, offering the \gls{api} to the Service Discovery, the \gls{poc} is automatically able to be routed through the \gls{api} gateway, discovered and requested by other services of the platform using both, the \gls{api} gateway and the Service Discovery, and to be auto-scalled by the underlying Docker Engine and the deployment with the Docker-Compose Container orchestration mechanisms.

				Further, \cref{fig:poc_service_diagram} presents on the right site the core functionality of the \gls{poc}.
				The Service Discovery Client binds the \gls{poc} to the Service Discovery Server of the platform, allowing to be seamlessly integrated into the platform.
				The \gls{opcua} Client Service implements the connection to the machine tools, retrieved from the part data and the machine tool Entity representation.
				On the other hand, the Client Service creates the connection, using the provided Client Generator, implementing a generic connection utility for security credentials, machnine-tool data and further required information to establish a clean connection. Finally, the \gls{opcua} Client Service can produce parts automatically, by triggering the Scheduling Service to retrieve the production date and time of the part to be produced next, and comparing to the system time, triggering the automatic start of a part production as the machine tool is available and its state is not an error state.
				The Service functionality is made public by a single \gls{api} wrapper.
				It shozld be noticed, that the Client Service functionality is implemented in an asynchronous manner, as data transfer and part production can take quite a long time and the client should not wait so long to inform the user about a success or a failure. Therefore, the client will respond to the user at the moment, as all paradigms for a successful file transfer or production start are given. After the \gls{http} response, the user is informed over the event messages, sent to the message broker, available at global scope for the entire \gls{rnp} platform. This approach ensures a user experience with no deadlocks and at the same time paralleling production processes.

			\subsection{Workflow Concept} \label{subsec:workflow_concept}

				Targeting the goal to be able to upload \gls{gcode} to the \gls{rnp} platform, to transfer the \gls{gcode} to a connected machine tool and to produce the production part described with the \gls{gcode}, the general workflow of the whole part production of the \gls{poc} using the \gls{opcua} protocol will now be described. The workflow is described using a \gls{uml} Sequence Diagram in~\cref{fig:poc_workflow_diagram} as specified in~\cite{uml2017}.
				
				\Cref{fig:poc_workflow_diagram} shows the interactions between the following four actors:
				
				\begin{enumerate}
					
					\item The \textit{Vendor}, representing a manufacturer wanting to start or stop a production workflow.
					
					\item The \textit{\gls{opcua} Client Service} (the \gls{poc}) integrated into the \gls{rnp} platform.
					
					\item The \textit{\gls{opcua} Server} attached to the machine tool, which should produce the required part.
					
					\item The \textit{OSACA}, a real physical machine tool provided by the \gls{isw} for the scope of this thesis.
					
				\end{enumerate}
				
				User interactions with the \gls{poc} are realized by triggering the \gls{rest}-ful \gls{api} provided by the \gls{poc} using \gls{json} over \gls{http} as communication base.
				System information related to other components of the system and to the user are implemented using asynchronous messaging with the \gls{amqp} provided by the global message broker of the \gls{rnp} platform.
				Communication between the system and the machine tool, which should produce the part, is managed by the \gls{opcua} protocol as described in \cref{sec:opc_ua}.
				
				This work refers to the basic workflow of the \gls{poc} as the implementation of the Use Cases to upload \gls{gcode}, request the current machine tool state, the transfer of \gls{gcode} to the machine tool and the start of the part production, as shown in \cref{tab:use_case_upload,tab:use_case_check_machine,tab:use_case_transfer_code,tab:use_case_production_control}.

				\Cref{fig:poc_workflow_diagram} describes the first steps of the process of the Use Case for \gls{gcode} transfer shown in~\cref{tab:use_case_upload}, in which the user has \gls{gcode} prepared from the \gls{cad} file of the part to be produced. The user sends an \gls{http}-POST request in \gls{json} format to the system, containing his authentication header, the \gls{gcode} to be uploaded to the system, the identifier of the machine tool that should produce the part and the production time of the part. It should be mentioned, that by sending the identifier of a selected machine tool to produce specific part, the service checks if the catalog contains multiple machine tools with the same configuration parameters. If this is the case, one machine tool that is available at the production time of the part will be selected to produce the part.

				Receiving the user request, the service checks if the request is valid and if the user has the required permissions to perform the \gls{api} call. If the requirements are not met in the request it will be rejected and the user gets an information in the \gls{api} response. Assuming that the request has been sent correctly, the service starts to check the machine tool catalog and the configurations of the production process.
				
				If the configuration check and the following persistence of the production part and the machine tool connection (referring to an \gls{opcua} connection to the \gls{opcua} Server of the machine tool) is successful, the user request is finished with a positive response and the automatic production process starts.
				
				By starting the automatic part production, the \gls{poc} checks every second, if the order of the parts to be produced is still consistent with production dates of all valid parts in the database. Is the current system time 30 minutes away from the start of the production, the system begins to transfer the \gls{gcode} data of the part to the machine tool by firstly checking the current machine status (not including that the machine tool can be in production mode) as shown in \cref{tab:use_case_check_machine} and begins to transfer the \gls{gcode} data to the machine tool as described in \cref{tab:use_case_transfer_code}.
				
				In the case, that the production paradigms are not met, the part will be rescheduled in the database to a deferred state and the manufacturer user is informed over an asynchronous message. In the other case that, all requirements are met, the production is started at the moment the system times equals the part production time. After the successful production of the part, the user is again informed over an asynchronous message.
				
				\begin{figure}[H]
					\centering
					\includegraphics[width=\textwidth]{part_production_sequence.jpg}
					\caption{Sequence diagram of the general part production process}
					\label{fig:poc_workflow_diagram}
				\end{figure}
				
				By describing the workflow shown in \cref{fig:poc_workflow_diagram} all the requirements and Use Cases described in \cref{sec:requirements} have been handled. 
				Further, this work highlighted that with the prior knowledge of the concepts described in \cref{ch:foundations} and the analysis of the system, it is possible to model an automatic manufacturing process only relying on Open Source Technologies and the \gls{opcua} specification. 
				In \cref{subsec:machine_tool_intergation}, the machine tool integration between the \gls{rnp} \gls{opcua} Client Service running in the Cloud and the machine tool itself will be described to finalize the whole manufacturing process model.
				
				Nevertheless, it should be mentioned that in the scope of this \gls{poc}, the production workflow rely on the provided \gls{opcua} functionalities of the Beckhoff TwinCAT V3 \gls{opcua} server provided by the \gls{isw} for this work. It is further assumed, that the provided functionalities can be triggered as described in~\cite{twincat2018} by only executing the appropriate \gls{opcua} Client \gls{api} calls from the client to the server side. As result, this work has to notice, that only under the case, this assumption is correct, the interactions between the \textit{\gls{opcua} Client Service}, \textit{\gls{opcua} Server Service} and the machine tool \textit{OSACA} actors, can be successfully implemented. 
				Only under these assumptions a \gls{poc} can be implemented, without taking any changes on the machine tool side and ensure a machine tool and control unit independent manufacturing approach in the \gls{poc}.

			\subsection{Machine Tool Integration} \label{subsec:machine_tool_intergation}

				In \cref{subsec:workflow_concept} this work presented the concept of the regular workflow for the automatic part production of the \gls{poc}. 
				The description of the machine tool integration side will finalize the model. 
				The machine tool will be integrated using its \gls{opcua} server.

				To check the machine tool status, the client will read the current status data from the servers \textit{UA\_AddressSpace}. 
				These variables are set machine tool specific and have to be determined for each server and machine tool. 
				For the \gls{poc},the Beckhoff TwinCAT V3\footnote{\url{http://www.beckhoff.de/twincat3/}} control will be used and \gls{opcua} server for demonstration and testing purposes and describe machine tool specific commands using its specification defined in~\cite{twincat2018}. 
				The machine tool for experiment purposes is a 3-axis milling machine provided by the \gls{isw}, called \textit{OSACA}.

				The machine tool status check is handled, using the standard \gls{opcua} client read function to determine, if the current machine state in the TwinCAT NameSpace is not of type \textit{AlarmType} in the \textit{UA\_StatusCode}. If no entry is currently provided for any of these types (described in Clause 8.2 of~\cite{twincat2018}) under the \textit{DeviceState} \gls{opcua} Object, the machine tool has no error state and it leaves us to check, if the machine tool is ready for part production or currently producing a part. The check if the machine tool is currently producing a part, is done by checking, if any motion state changes arrived in the \textit{UA\_NodeGetHandleList} as if the production is ready, the event list is empty. Connectivity analysis of the machine tool is handled implicitly as every read request of data requires a valid \gls{opcua} connection.

				For read and write operation calls sent by an \gls{opcua} Client to an \gls{opcua} Server, the\gls{opcua} protocol specifies a standard \textit{UA\_FileType}~\cite{opcfoundation2017part5} which should be implemented by the \gls{opcua} server for the specific control used by the machine tool. The \textit{UA\_FileType} is represented by an array of bytes sent over the \gls{opcua} connection. For the purpose of this \gls{poc}, the data sent during the connection is only encrypted using the \gls{opcua} security mechanisms described in~\cite{opcfoundation2017part1} to avoid encoding and decoding complications at the testing of the \gls{poc}.
				
				Transferring of a \gls{gcode} data file is therefore handled by the \gls{poc} as follows:

				\begin{enumerate}
					\item The Client connects to the Server and checks if a program with the file name of the \gls{gcode} data already exists.
					\item If the \gls{gcode} already exists, the client appends temporary the system date to the file name and triggers the creation of a new \textit{UA\_FileType} in the programs folder for the project.
					\item After the empty file is created on the Server side, the client writes a byte stream into the file created using an \textit{UA\_Write} command to the server.
					\item Finishing the writing command, the client triggers the naming of the file and the setting of project specific parameters.
				\end{enumerate}

				In the last step of the part production after successfully transferring the \gls{gcode} down to the \gls{plc} of the machine tool using the \gls{opcua} server, the \gls{poc} can now start the part production at the required time. 
				Therefore, the \gls{opcua} Client Service of the gls{poc} triggers the \gls{opcua} server to create a new \textit{Task} in the TwinCAT automation project and execute it using the predefined workflow in \textit{UA\_Method} and \textit{UA\_Function} calls in the \gls{plc}.

				It should be mentioned that for a machine tool independent implementation, the \gls{opcua} server configurations and provided methods have to be homogeneously distributed over all machine tools connected with the platform. More precise information and a deeper discussion on that point follows in~\cref{sec:limitations}.

			\subsection{Security} \label{subsec:security}

				Besides the implementation of an automatic part production from the Cloud, it should be mentioned that business relevant data passes the processes from to the Cloud, and down to the machine tools of manufacturers, which leads us to the need of securing the data transfer and providing some kind of user access and permission control. 
				As the field of security is far beyond the scope of this work, some security approaches taken to secure the platform and the developed \gls{poc} only by touching the huge field of security in the manufacturing environment should be presented in the following.

				First of all, the Client service in the Cloud should check, if the data uploaded is really \gls{gcode} on no other format. Therefore, a \gls{gcode} parsing library is used to check the content of the \gls{gcode} data and to prove, that no other parameters are set. Further, a header check is required to determine the file format for parsing. If not each of these criteria is given, the file upload is aborted, ensuring no harmful data can be uploaded to the Cloud.

				User access and permissions to access the \gls{api} is regulated by the Oauth2 protocol to handle user access sessions to the system. Only users with the appropriate access tokens can send requests to each service of the \gls{rnp} platform, including the \gls{poc}. Besides that, only the manufacturers identified by their tokens, can see the machine tools they own and trigger the data transfer to them, which builds an additional security layer.

				Finally, the access on machine tool level is secured using the \gls{opcua} security mechanisms. Each \gls{opcua} server of each machine tool has a fine granulated access and method call description secured using identity certificates. The \gls{poc} initializes the certificate negotiation at the first time, the machine tool is bound to the cloud platform. The service itself can only add \gls{gcode} files to the machine tool \gls{plc} but can't remove data from or interrupt native \gls{plc} implementations.
				
		\section{Conclusion}\label{sec:concept_conclusion}
		
			This chapter introduced the concept for integrating a \gls{poc} into the \gls{rnp} \gls{cm} platform.
			First, the \gls{rnp} platform was analyzed and infrastructural, architectural and functional requirements for the \gls{poc} were distilled from the analysis made beforehand. 
			The architecture for the \gls{poc} has been described as a \gls{soa}.
			The \gls{poc} will be packaged into a Docker container, bound to a second Docker container containing the \gls{sql} database serving as persistence layer for the \gls{poc} and will provide its functionality with a \gls{rest}-ful \gls{api}.
			The \gls{poc} will finally be bound to the \gls{opcua} server of the machine-tool to be integrated only relying on the \gls{opcua} protocol.
			This chapter described the binding process in more detail.
			Subsequently, Use Cases have been divided into mandatory and optional ones, which then have been described in more detail to ensure later comparison of the implemented \gls{poc} against them.
			Finally, basic security concepts and suggestions concluded this chapter by suggesting the usage of the OAuth2 authentication protocol for securing the \gls{poc} \gls{api} and the utilization of the security mechanisms already implemented in the \gls{opcua} protocol.

	\chapter{Discussion} \label{ch:discusion}

		In this chapter, this work will compare the concept and approach described in \cref{ch:concept} to the actual implementation and experimental work with the \gls{poc}.
		\Cref{sec:main_objective} summarizes the motivation and goals of this work.
		In~\cref{sec:discussion_approach}, a recapitulation over the procedure for implementing the goals set is taken. 
		\Cref{sec:integration_results} will provide the results of how well the \gls{poc} could be integrated into the \gls{rnp} platform. Comparison of the self defined Use Cases and goals set for the scope of this work with the actual implementation will be described in \cref{sec:use_cases_implementation}. Finally, limitations of the \gls{poc} and the whole approach are shown in \cref{sec:limitations} closing this chapter.
		
		\section{Main Objective}\label{sec:main_objective}
		
			The \gls{rnp} platform presented in~\cref{sec:rent_n_produce} aims to model and simulate the whole \gls{cm} process, described in~\cref{sec:cloud_manufacturing}; from ordering manufacturing resources, the planning and scheduling of production processes, to provisioning and controlling physical machine tools from the Cloud platform. As \gls{rnp} lacked the functionality of communicating and transferring production data down to bound machine tools as shown in~\cref{subsec:initial_architecture}, this thesis aimed to model, specify and integrate a \gls{poc} to provide the platform with exactly these functionalities. In the context of research related to this work as highlighted in~\cref{ch:state_of_the_Science}, this thesis focused on implementing a \gls{poc} that is machine tool independent and only relying on the \gls{opcua} communication protocol trying to show, that by using \gls{opcua}, machine tool and \gls{cm} platform independent control over the Cloud is possible and applicable to manufacturing sites. 
			Described in more detail in~\cref{sec:opc_ua}, this work refers to \gls{opcua} as the machine tool abstraction architecture, abstracting machine tool control, security and operational signals, in a unified architecture by realizing an architecture, where the Server resides on the machine tool and executes commands from the clients. This principle is often described as an inverted client-server communication system.
			
			The functionality of the \gls{poc} had to be tested with a productive manufacturing unit provided by the \gls{isw} for this work.
			The motivation of this work was to transfer production part descriptions in \gls{gcode} format down to the machine tool and start the part production, only relying on the \gls{opcua} protocol.
			
			Since the \gls{rnp} platform has been developed by using the concepts and technologies described in~\cref{subsec:architecture}, the approach for the integration has been the same way, as presented in~\cref{sec:approach}. This resulted in the usage of technologies and concepts described in~\cref{ch:state_of_the_art}. As a result, a Spring Boot Service was implemented using the \gls{java} programming language, virtualized and encapsulated into a Docker container and integrated into the \gls{soa} architecture providing its functionalities by a \gls{rest}-ful \gls{api}. Further, \gls{opcua} related functionalities and abstractions have been realized using the Eclipse Milo \gls{java} Framework. 
			On the basis of the developed requirements and set goals, the \gls{poc} had to be substantiated with a concept, which is shown in~\cref{ch:concept}.
		
		\section{Approach}\label{sec:discussion_approach}
		
			To achieve the objective recapitulated in~\cref{sec:main_objective}, the steps described in~\cref{ch:concept} have been evaluated and executed. The evaluation and integration processes of the \gls{poc} have been divided into~\cref{sec:requirements} and~\cref{sec:approach}.
			
			\Cref{sec:requirements} distilled the relevant requirements and features to be implemented into the \gls{poc} by analyzing the initial state and functionality of the \gls{rnp} platform. Use Cases have been defined to clear the scope of the \gls{poc} as well, as to ease the development process of the \gls{poc}.
			
			The approach of the implementation of the \gls{poc} has been described in~\cref{sec:approach}. Here, integration details and the target architecture have been described. A detailed presentation of the components included in the \gls{poc} as well as the machine tool communication workflow using \gls{opcua} has been given in~\cref{subsec:services,subsec:workflow_concept,subsec:machine_tool_intergation} as well as the binding of the machine tool to the \gls{rnp} platform. 
			The resulting \gls{poc} has further been tested against a Beckhoff TwinCAT V3 \gls{opcua} Server and \gls{plc}.
			Finally, basic security implementations included into the \gls{poc} have been described in~\cref{subsec:security}.
			
		\section{Integration Results}\label{sec:integration_results}

			After implementing the \gls{poc} with the requirements defined in \cref{sec:requirements} and the goals of this work listed in~\cref{sec:goals} in mind, the developed \gls{poc} could be totally integrated into the \gls{rnp} platform as planned. By using the Docker container runtime, the \gls{poc} could potentially be integrated into any \gls{paas} solution and architecture, running on the Docker Engine as container and orchestration platform.

			The implemented \gls{rest}-ful \gls{api} encapsulates all functionalities of the \gls{poc} and provides it to any third-party service, that is able to communicate using \gls{json} over \gls{http} and receive messages from an \gls{amqp} message broker. The database serving the \gls{poc} service can be interchanged to any \gls{sql} database as well as additional components like Caching, Searching and Logging utilities can be added by accessing the Spring Framework \gls{api} and its provided integration functionalities.

			As the OAuth2 protocol is provider independent, custom implementations of a user access and permission management system can be added or replace the current implementation. Same criteria were met for the service discovery and \gls{api} gateway Cloud Computing patterns as described in~\cite{leymann2011cloud}.
			The \gls{opcua} functionalities of the service are encapsulated to the service itself, providing an extensible and generic \gls{opcua} Client Service supporting the \gls{opcua} protocol only limited by the functionalities provided by the Eclipse Milo Client Library implementation.

			Summing up the results, the \gls{poc} could be implemented and integrated seamlessly to the \gls{rnp} platform. With this result, the \gls{poc} fulfills the first four abstractly defined goals, shown in~\cref{sec:goals}, that the \gls{poc} should be platform independent and serving a standard \gls{api}.

		\section{Use Case Implementation}\label{sec:use_cases_implementation}

			After defining the Use Cases in \cref{subsec:mandatory}, this work will prove each of them against the actual implementation of the \gls{poc}. This will serve as a proof for the concept and unveil limitations of the concept presented in~\cref{ch:concept}.

			\subsection{Uploading of Production Data}\label{subsec:uploading_g_code}

				By offering the \gls{api} to upload simple files in the \gls{gcode} file format, this Use Case is proofed by the \gls{poc}. Files can be uploaded and before persisting the files for a specific production step, the system checks, if the header parameters for the file type and the file content itself is \gls{gcode} compliant. Requests with any other type of data will be rejected. Exception handling was implemented to handle unauthorized requests, wrong request contents and unspecified parameters as well as requests to \gls{api} entry points not containing the requested data.
				It should be concluded, that the \gls{poc} implements the Use Case as described in~\cref{tab:use_case_upload}.

			\subsection{Machine-Tool Status Checking}\label{subsec:machine_tool_status_checking}

				The implemented \gls{poc} provides an \gls{api} for checking the current machine tool status. Behind this \gls{api}, a generic \gls{opcua} connection utility generates \gls{opcua} connections for the provided machine tools already persisted in the database beforehand. The \gls{api} implements an enumeration-based approach for different connection security requirements, to provide granulated access to the specific values requested by the user. Anonymous connections can be established, as well as connection using specific \textit{Username} and \textit{Password} credentials or Client-Server Certificate pairs.

				An asynchronous connection is built each time the \gls{opcua} \gls{api} of the \gls{poc} is triggered, checking the following parameters:

				\begin{enumerate}
					\item Is the machine tool available over Ethernet?
					\item Is the machine tool available for a connection over \gls{opcua}?
					\item Is the machine tool currently in an \gls{opcua} error state?
				\end{enumerate}

				As the last parameter is machine tool specific and relies on the \gls{opcua} server implementation on the machine tool; in the scope of this \gls{poc} only the functionalities provided by the TwinCAT V3 control unit used in this work and specified in~\cite{twincat2018} are referenced. More details on this machine tool specific approach will be discussed in \cref{sec:limitations}. Nevertheless, the \gls{poc} provides the \gls{api} as described in the Use Case shown in~\cref{tab:use_case_check_machine}, which leads us to the conclusion, that the \gls{poc} provides the functionality required. This statement is argued by the evidence, that the \gls{poc} implements this functionality in total accordance to the \gls{opcua} Client \gls{api} and the \gls{opcua} Server \gls{api} of the TwinCAT V3 specified in~\cite{twincat2018}, as described in~\cref{subsec:machine_tool_intergation}.

			\subsection{Production Data Transfer}\label{subsec:g_code_transfer}

				With the possibilities implemented in the \gls{poc}, as described in \cref{subsec:machine_tool_status_checking}, the machine tool status can be checked, before a previously uploaded \gls{gcode} file can be transferred to the machine tool to produce the part. The approach described in \cref{subsec:machine_tool_intergation} is the standard process to complete a file transfer following the \gls{opcua} specification respectively to the TwinVAT V3 specification~\cite{twincat2018} used as control unit for the \gls{poc}.

				After monitoring and logging the requests sent in each step of the transfer workflow described in \cref{fig:poc_workflow_diagram}, this work ensures that the implemented functionality is correct on the side of the \gls{opcua} Client Service \gls{api}, as it reflects the suggested \gls{opcua} process and data flow. An interesting recognition taken from the experiment to transfer \gls{gcode} data to the TwinCAT V3 \gls{plc} has been, that even if the TwinCAT V3 offers the described \gls{api} to handle \gls{opcua} \textit{UA\_FileType} requests, the \gls{opcua} server of the machine tool responded, that the requested function is not available and returns a \textit{UA\_StatusCode} showing a correct request but bad response.
				
				This issue has been further analyzed down to the recognition, that the \gls{opcua} Server side cancels, the request due to \textit{UA\_UserWriteMask} permission problems. Further, this work revealed from the TwinCAT V3 specification~\cite{twincat2018}, that the read and write permissions, can only be manipulated on the Server side of the connection, making it impossible for third-party applications like the \gls{poc} to manipulate access and permission hierarchies. 
				
				Since the permission and write-access issues unveiled the fact, that the implemented \gls{poc} is not capable to manipulate \textit{UA\_AddressSpace} permissions and hierarchies on the TwinCAT V3, further tests have been processed to find out, whether the \gls{poc} implementation would work on a different \gls{opcua} Server implementation.
				Therefore, a Prosys \gls{opcua} Simulation Server\footnote{\url{https://downloads.prosysopc.com/opc-ua-simulation-server-downloads.php}} was bound to the \gls{poc}, not changing the configurations; neither of the Simulation Server, nor the ones of the \gls{poc} to test the implemented functionalities and unveil potential implementation errors. 
				Surprisingly, it was noticed that the \gls{poc} could create a new \textit{UA\_FolderNode} in the \textit{UA\_AddressSpace} of the \gls{opcua} Simulation Server, further creating and opening a new file, writing the \gls{gcode} content into it and finally persist it on the \gls{opcua} Server side. After further investigation it was found, that the Prosys Simulation Server allows the creation of files and manipulation of the \textit{UA\_AddressSpace Objects}, without further specifying user permissions. The tests worked as expected for each kind of connection: anonymous connections, certificate-based authentication connections and user-specific connections.
				
				These results led us to the conclusion, that the functions implemented in the \gls{poc}, as well as the \gls{opcua} function calls themselves have been implemented correctly. It is concluded that the permissions and function call implementations on the \gls{opcua} Server side have to configured beforehand and provisioned to the \gls{poc}, so afterwards manufacturing processes can be modeled. This realization contradicts the concept to create a \gls{plc} and machine tool independent service for file transfer and production. The hereby unveiled limitations will be discussed in more detail in \cref{sec:limitations}. 
				In summary, this work has shown with the \gls{poc}, that it is possible to transfer \gls{gcode} data for part production using the \gls{opcua} protocol.

			\subsection{Part Production}\label{subsec:part_production}

				As described in~\cref{subsec:g_code_transfer}, the transfer of real production data in \gls{gcode} format, down to the machine tool provided for testing, could not be completely tested. 
				Nonetheless, the \gls{poc} implements the functionality to read and set status data on the TwinCAT V3 \gls{plc} using its \gls{opcua} Server, according to~\cite{twincat2018}.
				As expected, these data were available to be read and written over \gls{opcua} and the \textit{UA\_StatusCodes} and \textit{UA\_Types} could be read, handled complications.
				
				However, it was as expected as well, that the \gls{poc} was not able to write and set the values, as needed to send a production start or production stop signal. 
				Once again, the TwinCAT V3 expects previous server configurations to allow data manipulation on the server side. 
				
				Additionally, the TwinCAT V3 environment expects, that \gls{gcode} data for part production, is present on the system in the context of the integrated development and production environment on the TwinCAT V3, which means, that besides a potential transfer of \gls{gcode} data using \gls{opcua} from the \gls{poc} to the \gls{opcua} Server of the TwinCAT V3, the data has to be loaded into 	the \gls{nc} part of the TwinCAT V3 control. 
				Even with the fact, that the TwinCAT V3 \gls{opcua} \gls{api} provides predefined \textit{UA\_Functions} for these operations, the \gls{gcode} files have to be properly linked beforehand in the \textit{UA\_AddressSpace}, which underlies several permission restrictions and security limitations, making it impossible for the \gls{poc} to accomplish this manufacturing process task.

				Assuming, that the parameters could be read and written under the fitting \textit{UA\_UserWriteMask}, the expectation was made that with a proper configuration of the \gls{opcua} server of the \gls{plc} the start and stop of the production, would simply trigger already implemented functions on the \gls{plc} to pursue with the part production. 
				However, with the issues described in~\cref{subsec:g_code_transfer,subsec:part_production}, the last of the five goals set in~\cref{sec:goals} could not be totally fulfilled.

		\section{Limitations}\label{sec:limitations}

			As a result of the test of the \gls{poc} against the Use Cases and requirements define beforehand, it was found out that the requirements could not be totally met.
			Although the \gls{poc} have been seamlessly integrated into the \gls{rnp} platform, a fully machine tool and control unit independent functionality could not be implemented. 
			Even with the fact, that the \gls{poc} could provide the functionality to integrate \gls{opcua} Client \gls{api} functionality into itself and establish \gls{opcua} connections in a generic manner, restriction to the transfer of control signals down to the machine tool have been discovered.
			
			In~\cref{subsec:g_code_transfer} the issue was described that the handling of \textit{UA\_FileType Objects} depends on the provided functionality of the \gls{opcua} Server of the machine tool. 
			Further, the provided functionalities can vary between different Servers, even if they implement the same \gls{opcua} Server \gls{api} specification. More precise, even if the Server side implements the handling of the necessary events to transfer a \gls{gcode} file, the permission hierarchy on the server-side has to be configured, before the machine tool is bound to the \gls{poc}. This leads us to the fact, that the \gls{poc} has to be able to recognize provided functionalities of the Server side by iterating the \gls{opcua} Server \textit{UA\_AddressSpace} as well as to have the permission to execute \textit{UA\_AddressSpace} manipulations.

			Further limitations have been found during the research phase of the project. Dependent on the real-time requirements of the system, it could be possible, that the \gls{poc} doesn't fit these requirements as a data, signal and file transfer to the control units can take a while, missing the required real-time signal slots. 
			Further, the \gls{poc} totally depends on a prior knowledge of the \gls{opcua} addresses and security configurations from the manufacturer as that these have to be provided during the persistence of machine tools to the \gls{rnp} platform. 
			Finally, an automatic provisioning of the machine tools by their \gls{opcua} addresses is still not possible, as the types, versions and software states of the manufacturers \gls{plc}s can be highly heterogeneous, making it impossible for the \gls{poc} to know which kind of services the \gls{plc} really supports, making the need of a kind of gateway inevitable.
			
		\section{Conclusion}\label{sec:discussion_conclusion}
		
			In this chapter, the results of the testing of the implemented \gls{poc} against the previously defined requirements and the concept described in~\cref{ch:concept} were presented.
			For the integration of the \gls{poc} into the \gls{rnp} platform the results showed, that the \gls{poc} specified in the concept could be integrated seamlessly into the platform.
			Further, the requirements of the Use Cases to upload, persist and schedule production data as \gls{gcode} as well as the request of the current machine tool status could totally be met by the implemented \gls{poc}.
			
			As described in~\cref{subsec:g_code_transfer,subsec:part_production} limitations and negative results have been revealed.
			It was noted that the transfer of production data to the connected machine tool depends heavily on the implementation of the \gls{opcua} server attached to it. 
			For this reason, an automated and machine tool independent production from the Cloud could not be simulated on provided physical machine tool.
			Nevertheless, it could be shown that the \gls{poc} on the \gls{opcua} Client \gls{api} side correctly implements the \gls{opcua} protocol and that these tests after; a specific adaptation to the \gls{opcua} Server of the machine tool would have turned out positive.
			Finally, a closer discussion in~\cref{sec:limitations} on the exact background of the problem was led.

	\chapter{Conclusion and Future Work} \label{ch:conclusion_and_future_work}

		This Chapter provides a short summary of this work in~\cref{sec:conclusion}. In addition, future work on the system is proposed and possible Use Cases are discussed in~\cref{sec:future_work}.

		\section{Conclusion}\label{sec:conclusion}

			In this work, an approach for the automated part production in the manufacturing field using the \gls{rnp} platform and the \gls{opcua} specification has been proposed. To accomplish this task, a concept has been derived from the analysis of the \gls{rnp} \gls{cm} platform and its missing functionalities at the beginning of this work.

			First, foundations of \gls{cm} and the \gls{opcua} specification were presented. This provided a base for examining the state of the art, the state of the research and related work.
			With the aid of observations made in foundational as well as related work, an approach implementing a working \gls{poc} which seamlessly integrates into the \gls{rnp} platform was presented. 
			The \gls{poc} encapsulates its functionality in a Docker container and provides it through a \gls{rest}-ful \gls{api} to be platform and language independent. 
			Further, persistence and management models were developed and integrated into the \gls{poc}. 
			The \gls{opcua} and machine tool integration was implemented following the principles of the \gls{opcua} specification.
			It has been found out, that even if the Cloud-based client implements the specified \gls{opcua} functionalities, it is still a matter of machine tool configuration, making a truly machine tool independent solution not possible with this \gls{poc}. Finally, this work summarized the limitations of the \gls{poc} and the approach as well as providing information about the architecture and implementation for future research work.

		\section{Future Work}\label{sec:future_work}

			The presented approach is not totally machine tool independent, as it relies on the server-side implementations provided as \gls{opcua} interfaces. 
			For a better handling and analyzation of manufacturing sites topologies, it is suggested to provide a supplement service for \textit{scanning} of the manufacturing sites, which should allow the service to get insights to the individual topologies.
			In addition, the \gls{poc} currently expects from the users, that they exactly know the addresses and configuration details of their machine tools. One could image to make research on manufacturing site provisioning and automatic registration of machine tools to the platform with ideal information about the possible manufacturing processes.
			At last, future research could extend the current \gls{rnp} platform and especially the \gls{poc}, to implement a central authorization and certificate management service for all machine tools of a production site. 
			This would ease the configuration and access management of each machine tool and lead to a higher security level and usability of the whole platform.

	\clearpage

	% \printindex

	\printbibliography

	All links were last followed on \today.

	\pagestyle{empty}
	\renewcommand*{\chapterpagestyle}{empty}
	\Versicherung

\end{document}
